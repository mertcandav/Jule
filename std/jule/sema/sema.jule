// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast
use build for std::jule::build::{Directive, Derive, LogMsg, Log, LogKind, Logf}
use std::jule::constant::{Const}
use std::jule::lex::{File, Token, TokenKind, IsIgnoreIdent, IsAnonIdent}
use types for std::jule::types
use strings for std::strings

fn isValidModelForRef(mut &m: ExprModel): bool {
    match type m {
    | &Var:
        ret true
    | &StructSubIdentExprModel:
        let mut model = (&StructSubIdentExprModel)(m)
        ret isValidModelForRef(model.Expr.Model)
    | &TraitSubIdentExprModel:
        let mut model = (&TraitSubIdentExprModel)(m)
        ret isValidModelForRef(model.Expr)
    | &UnaryExprModel:
        let mut unary = (&UnaryExprModel)(m)
        if unary.Op.Kind != TokenKind.Star {
            ret false
        }
        // Return true because of pointer dereferencing is an Unsafe Jule feature.
        if unary.Expr.Kind.Ptr() != nil {
            ret true
        }
        // Dereferencing should be smart pointer, in other words return false.
        if unary.Expr.Kind.Sptr() == nil {
            ret false
        }
        ret isValidModelForRef(unary.Expr.Model)
    |:
        ret false
    }
}

fn compilerErr(&token: &Token, line: bool, fmt: LogMsg, args: ...any): Log {
    let mut log = Log{
        Kind: LogKind.Error,
        Row: token.Row,
        Column: token.Column,
        Path: token.File.Path,
        Text: Logf(fmt, args...),
    }
    if line {
        log.Line = token.File.GetRow(token.Row)
    }
    ret log
}

fn impIsLookupable(&i: &ImportInfo, ident: str): bool {
    if i.CppLinked {
        ret false
    }
    if !i.ImportAll {
        if len(i.Selected) > 0 {
            ret i.existIdent(ident)
        }
    }
    ret i.ImportAll
}

fn appendRetVars(mut &dest: []&Var, mut &f: &FnIns) {
    if f.Decl.IsVoid() || f.Result == nil {
        ret
    }

    let mut types = f.Types()
    for (i, mut ident) in f.Decl.Result.Idents {
        if IsIgnoreIdent(ident.Kind) || IsAnonIdent(ident.Kind) {
            continue
        }
        dest = append(dest, &Var{
            Used: true,
            Mutable: true,
            Ident: ident.Kind,
            Token: ident,
            Scope: f.Scope,
            Kind: &TypeSymbol{
                Kind: types[i],
            },
            Value: &Value{
                Data: new(Data),
            },
            RetOrder: i,
        })
    }
    if len(f.Decl.Result.Idents) == 1 && len(dest) == 1 {
        dest[len(dest)-1].RetOrder = -1
    }
}

fn appendParamVars(mut &dest: []&Var, mut &f: &FnIns) {
    if len(f.Params) == 0 {
        ret
    }

    for (_, mut p) in f.Params {
        if IsIgnoreIdent(p.Decl.Ident) || IsAnonIdent(p.Decl.Ident) {
            continue
        }

        let mut v = &Var{
            Used: true,
            Reference: p.Decl.Reference,
            Mutable: p.Decl.Mutable,
            Ident: p.Decl.Ident,
            Token: p.Decl.Token,
            Kind: new(TypeSymbol),
            Scope: f.Scope,
            Value: &Value{
                Data: new(Data),
            },
        }

        match {
        | p.Decl.IsSelf():
            v.Kind.Kind = &TypeKind{
                Variadic: false,
                Kind: f.Owner,
            }
            v.Reference = !p.Decl.IsRef()

            if p.Decl.IsRef() {
                v.Ident = v.Ident[1:] // Remove reference sign.
                v.Kind.Kind.Kind = &Sptr{
                    Elem: &TypeKind{
                        CppIdent: v.Kind.Kind.CppIdent,
                        Kind: v.Kind.Kind.Kind,
                    },
                }
            }
        | p.Decl.Variadic:
            v.Kind.Kind = &TypeKind{
                Variadic: false,
                Kind: &Slc{
                    Elem: &TypeKind{
                        CppIdent: p.Kind.CppIdent,
                        Kind: p.Kind.Kind,
                    },
                },
            }
        |:
            v.Kind.Kind = p.Kind
        }

        dest = append(dest, v)
    }
}

// Builds type aliases for generic types of scope.
// See developer reference (1), and (2).
fn appendGenericTypeAliases(mut &dest: []&TypeAlias, mut &f: &FnIns) {
    let mut size = len(f.Generics)
    if f.Decl.Owner != nil {
        size += len(f.Decl.Owner.Generics)
    }

    if size == 0 {
        ret
    }

    for (i, mut g) in f.Generics {
        let mut decl = f.Decl.Generics[i]
        dest = append(dest, &TypeAlias{
            Used: true,
            Generic: true,
            Scope: f.Decl.Scope,
            Ident: decl.Ident,
            Token: decl.Token,
            Kind: &TypeSymbol{Kind: g.Kind},
        })
    }

    if f.Decl.Owner != nil {
        let mut owner = f.Owner
        for (i, mut g) in owner.Generics {
            let mut decl = owner.Decl.Generics[i]
            dest = append(dest, &TypeAlias{
                Used: true,
                Generic: true,
                Scope: f.Decl.Scope,
                Ident: decl.Ident,
                Token: decl.Token,
                Kind: &TypeSymbol{Kind: g.Kind},
            })
        }
    }
}

fn findFile(mut &files: []&SymbolTable, &handler: &File): &SymbolTable {
    for (_, mut fl) in files {
        if fl.File == handler {
            ret fl
        }
    }
    ret nil
}

unsafe fn pushSugggestion(mut log: *Log, fmt: LogMsg, args: ...any) {
    log.Suggestion = Logf(fmt, args...)
}

// Semantic analyzer for tables.
// Accepts tables as files of package.
struct Sema {
    errors: []Log
    files:  []&SymbolTable // Package files.
    file:   &SymbolTable   // Current package file.
    flags:  SemaFlag
}

impl Lookup for Sema {
    // Returns imported package by identifier.
    // Returns nil reference if not exist any package in this identifier.
    //
    // Lookups:
    //   - Current file's imported packages.
    fn FindPackage(mut self, ident: str): &ImportInfo {
        ret self.file.FindPackage(ident)
    }

    // Returns imported package by selector.
    // Returns nil reference if selector returns false for all packages.
    // Returns nil reference if selector is nil.
    //
    // Lookups:
    //   - Current file's imported packages.
    fn SelectPackage(mut self, selector: fn(&ImportInfo): bool): &ImportInfo {
        ret self.file.SelectPackage(selector)
    }

    // Returns variable by identifier and cpp linked state.
    // Returns nil reference if not exist any variable in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    fn FindVar(mut self, ident: str, cpp_linked: bool): &Var {
        // Lookup package files.
        let mut v = findVarInPackage(self.files, ident, cpp_linked)
        if v != nil {
            ret v
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.Imports {
            if !impIsLookupable(imp, ident) {
                continue
            }
            v = imp.FindVar(ident, cpp_linked)
            if v != nil && self.isAccessibleDefine(v.Public, v.Token) {
                ret v
            }
        }

        ret nil
    }

    // Returns type alias by identifier and cpp linked state.
    // Returns nil reference if not exist any type alias in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    fn FindTypeAlias(mut self, ident: str, cpp_linked: bool): &TypeAlias {
        // Lookup package files.
        let mut ta = findTypeAliasInPackage(self.files, ident, cpp_linked)
        if ta != nil {
            ret ta
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.Imports {
            if !impIsLookupable(imp, ident) {
                continue
            }
            ta = imp.FindTypeAlias(ident, cpp_linked)
            if ta != nil && self.isAccessibleDefine(ta.Public, ta.Token) {
                ret ta
            }
        }

        ret nil
    }

    // Returns struct by identifier and cpp linked state.
    // Returns nil reference if not exist any struct in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    fn FindStruct(mut self, ident: str, cppLinked: bool): &Struct {
        // Lookup package files.
        let mut s = findStructInPackage(self.files, ident, cppLinked)
        if s != nil {
            ret s
        }
        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.Imports {
            if !impIsLookupable(imp, ident) {
                continue
            }
            s = imp.FindStruct(ident, cppLinked)
            if s != nil && self.isAccessibleDefine(s.Public, s.Token) {
                ret s
            }
        }
        ret nil
    }

    // Returns function by identifier and cpp linked state.
    // Returns nil reference if not exist any function in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    fn FindFn(mut self, ident: str, cpp_linked: bool): &Fn {
        // Lookup package files.
        let mut f = findFnInPackage(self.files, ident, cpp_linked)
        if f != nil {
            ret f
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.Imports {
            if !impIsLookupable(imp, ident) {
                continue
            }
            f = imp.FindFn(ident, cpp_linked)
            if f != nil && self.isAccessibleDefine(f.Public, f.Token) {
                ret f
            }
        }

        ret nil
    }

    // Returns trait by identifier.
    // Returns nil reference if not exist any trait in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    fn FindTrait(mut self, ident: str): &Trait {
        // Lookup package files.
        let mut t = findTraitInPackage(self.files, ident)
        if t != nil {
            ret t
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.Imports {
            if !impIsLookupable(imp, ident) {
                continue
            }
            t = imp.FindTrait(ident)
            if t != nil && self.isAccessibleDefine(t.Public, t.Token) {
                ret t
            }
        }

        ret nil
    }

    // Returns enum by identifier.
    // Returns nil reference if not exist any enum in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    fn FindEnum(mut self, ident: str): &Enum {
        // Lookup package files.
        let mut e = findEnumInPackage(self.files, ident)
        if e != nil {
            ret e
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.Imports {
            if !impIsLookupable(imp, ident) {
                continue
            }
            e = imp.FindEnum(ident)
            if e != nil && self.isAccessibleDefine(e.Public, e.Token) {
                ret e
            }
        }

        ret nil
    }

    // Returns type enum by identifier.
    // Returns nil reference if not exist any type enum in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    fn FindTypeEnum(mut self, ident: str): &TypeEnum {
        // Lookup package files.
        let mut e = findTypeEnumInPackage(self.files, ident)
        if e != nil {
            ret e
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.Imports {
            if !impIsLookupable(imp, ident) {
                continue
            }
            e = imp.FindTypeEnum(ident)
            if e != nil && self.isAccessibleDefine(e.Public, e.Token) {
                ret e
            }
        }

        ret nil
    }
}

impl Sema {
    // Reports whether flags has given flag.
    fn isFlag(self, flags: SemaFlag): bool { ret self.flags&flags == flags }

    fn setCurrentFile(mut self, mut f: &SymbolTable) { self.file = f }

    fn pushErr(mut self, token: &Token, fmt: LogMsg, args: ...any) {
        self.errors = append(self.errors, compilerErr(token, true, fmt, args...))
    }

    // Push suggestion to last log.
    fn pushSugggestion(mut self, fmt: LogMsg, args: ...any) {
        unsafe { pushSugggestion(&self.errors[len(self.errors)-1], fmt, args...) }
    }

    // Reports whether define is accessible in the current package.
    fn isAccessibleDefine(self, public: bool, token: &Token): bool {
        ret public || token.File == nil || self.file.File.Dir() == token.File.Dir()
    }

    // Reports this identifier duplicated in package's global scope.
    // The "self" parameter represents address of exception identifier.
    // If founded identifier address equals to self, will be skipped.
    fn isDuplicatedIdent(self, itself: uintptr, ident: str, cpp_linked: bool): bool {
        for _, f in self.files {
            if f.isDuplicatedIdent(itself, ident, cpp_linked) {
                ret true
            }

            for _, imp in f.Imports {
                for _, selected in imp.Selected {
                    if selected.Kind == ident {
                        ret true
                    }
                }
            }
        }
        ret false
    }

    fn checkDirectives(mut &self, mut &d: []&ast::Directive, mut o: any) {
        let mut dc = directiveChecker{
            s: self,
            d: unsafe { (&[]&ast::Directive)(&d) },
            o: o,
        }
        dc.check()
    }

    fn checkGenericQuantity(mut self, required: int, given: int, token: &Token): (ok: bool) {
        match {
        | required == 0 && given > 0:
            self.pushErr(token, LogMsg.NotHasGenerics)
            ret false
        | required > 0 && given == 0:
            self.pushErr(token, LogMsg.HasGenerics)
            ret false
        | required < given:
            self.pushErr(token, LogMsg.GenericsOverflow)
            ret false
        | required > given:
            self.pushErr(token, LogMsg.MissingGenerics)
            ret false
        |:
            ret true
        }
    }

    fn isDuplicatedImportSelection(self, itself: uintptr, ident: str): bool {
        for _, imp in self.file.Imports {
            if uintptr(imp) == itself {
                // Don't scan trailing imports.
                break
            }
            if imp.existIdent(ident) {
                ret true
            }
        }
        ret false
    }

    fn getImportDef(self, ident: str, mut &imp: &ImportInfo): any {
        if findPackageBuiltinDef(imp.LinkPath, ident) != nil {
            ret true
        }
        for (_, mut f) in imp.Package.Files {
            // C++-linked defines can't export.
            const CppLinked = false
            let mut def = f.defByIdent(ident, CppLinked)
            if def != nil {
                ret def
            }
        }
        ret nil
    }

    fn checkImportSelection[T](mut self, &ident: &Token, &s: T): bool {
        if !self.isAccessibleDefine(s.Public, s.Token) {
            self.pushErr(ident, LogMsg.IdentIsNotAccessible, ident.Kind)
            self.pushSugggestion(LogMsg.MakePubToAccess)
            ret false
        }
        const CppLinked = false // Exported defines cannot be linked.
        if defByIdentPackage(self.files, s.Ident, CppLinked) != nil {
            self.pushErr(ident, LogMsg.SelectedImportExistInPackage, s.Ident)
            ret false
        }
        ret true
    }

    fn checkImportSelectedSelections(mut self, mut &imp: &ImportInfo): (ok: bool) {
        ok = true
        for _, ident in imp.Selected {
            if ident.Kind == TokenKind.Self {
                continue
            }

            if self.isDuplicatedImportSelection(uintptr(imp), ident.Kind) {
                self.pushErr(ident, LogMsg.DuplicatedIdent, ident.Kind)
                self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
                ok = false
                continue
            }

            let mut def = self.getImportDef(ident.Kind, imp)
            match type def {
            | bool:
                // Pass, built-in.
                continue
            | &Var:
                let mut v = (&Var)(def)
                ok = self.checkImportSelection(ident, v) && ok
            | &TypeAlias:
                let mut ta = (&TypeAlias)(def)
                ok = self.checkImportSelection(ident, ta) && ok
            | &Struct:
                let mut s = (&Struct)(def)
                ok = self.checkImportSelection(ident, s) && ok
            | &Trait:
                let mut t = (&Trait)(def)
                ok = self.checkImportSelection(ident, t) && ok
            | &Enum:
                let mut e = (&Enum)(def)
                ok = self.checkImportSelection(ident, e) && ok
            | &TypeEnum:
                let mut e = (&TypeEnum)(def)
                ok = self.checkImportSelection(ident, e) && ok
            | &Fn:
                let mut f = (&Fn)(def)
                ok = self.checkImportSelection(ident, f) && ok
            |:
                self.pushErr(ident, LogMsg.IdentNotExist, ident.Kind)
                ok = false
                continue
            }
        }
        ret
    }

    fn checkImportsAllSelectionsFromCollection[T](mut self, &s: []T, &et: &Token): bool {
        let mut ok = true
        for _, d in s {
            if d.Public {
                ok = self.checkImportSelection(et, d) && ok
            }
        }
        ret ok
    }

    fn checkImportAllSelections(mut self, &imp: &ImportInfo): (ok: bool) {
        ok = true
        for _, file in imp.Package.Files {
            ok = self.checkImportsAllSelectionsFromCollection(file.Vars, imp.Token) && ok
            ok = self.checkImportsAllSelectionsFromCollection(file.TypeAliases, imp.Token) && ok
            ok = self.checkImportsAllSelectionsFromCollection(file.Structs, imp.Token) && ok
            ok = self.checkImportsAllSelectionsFromCollection(file.Funcs, imp.Token) && ok
            ok = self.checkImportsAllSelectionsFromCollection(file.Traits, imp.Token) && ok
            ok = self.checkImportsAllSelectionsFromCollection(file.Enums, imp.Token) && ok
            ok = self.checkImportsAllSelectionsFromCollection(file.TypeEnums, imp.Token) && ok
        }
        ret
    }

    fn checkImportSelections(mut self, mut &imp: &ImportInfo): (ok: bool) {
        if len(imp.Selected) > 0 {
            ret self.checkImportSelectedSelections(imp)
        } else if imp.ImportAll {
            ret self.checkImportAllSelections(imp)
        }
        ret true
    }

    fn isUseAliasDuplication(mut self, &imp: &ImportInfo): bool {
        if len(imp.Alias) == 0 {
            ret false
        }

        for (_, mut imp2) in self.file.Imports {
            if imp2 == imp {
                break
            }
            if imp2.Alias == imp.Alias {
                ret true
            }
            // Catch identifiers of other use declarations.
            if imp2.Ident == imp2.LinkPath && imp2.Ident == imp.Alias {
                ret true
            }
        }
        ret false
    }

    fn checkImport(mut self, mut &imp: &ImportInfo): bool {
        if imp.CppLinked || len(imp.Package.Files) == 0 {
            ret true
        }

        if self.isUseAliasDuplication(imp) {
            self.pushErr(imp.Token, LogMsg.DuplicatedUseAlias, imp.Alias)
            self.pushSugggestion(LogMsg.RenameUseAliasAvoidDuplication)
        }

        if !imp.Duplicate {
            let mut sema = &Sema{
                flags: self.flags,
            }
            sema.check(imp.Package.Files)
            if len(sema.errors) != 0 {
                self.errors = append(self.errors, sema.errors...)
                sema.errors = nil
                ret false
            }
        }
        ret self.checkImportSelections(imp)
    }

    fn checkImports(mut self) {
        for (_, mut file) in self.files {
            self.setCurrentFile(file)
            for (_, mut imp) in file.Imports {
                let ok = self.checkImport(imp)
                // Break checking if package has error.
                if !ok {
                    ret
                }
            }
        }
    }

    fn implFileImpls(mut &self) {
        for (_, mut imp) in self.file.Impls {
            self.implImpl(imp)
        }
    }

    fn implImpls(mut &self) {
        for (_, mut file) in self.files {
            self.setCurrentFile(file)
            self.implFileImpls()
        }
    }

    fn checkEnums(mut &self) {
        for (_, mut file) in self.files {
            self.setCurrentFile(file)
            self.checkEnumDecls()
        }
    }

    fn checkFileInherits(mut &self) {
        for (_, mut t) in self.file.Traits {
            let ok = self._checkTraitDeclInherits(t)
            if !ok {
                ret
            }
        }
    }

    fn checkInherits(mut &self) {
        for (_, mut file) in self.files {
            self.setCurrentFile(file)
            self.checkFileInherits()
        }
    }

    fn typeChecker(mut &self, mut l: Lookup, mut generics: []&TypeAlias,
        mut referencer: &referencer): typeChecker {
        let mut tc = typeChecker{
            s: self,
            rootLookup: l,
            lookup: l,
            referencer: referencer,
            useGenerics: generics,
        }
        match type l {
        | &scopeChecker:
            let mut hard = (&scopeChecker)(l).getHardRoot()
            tc.refers = hard.owner.Refers
        }
        // referencer's refs field is not nil if owner is type alias.
        if referencer != nil && referencer.refs != nil {
            // Set owner alias field of TypeChecker to collect generic dependencies.
            // See developer reference (4).
            match type referencer.owner {
            | &TypeAlias:
                tc.ownerAlias = (&TypeAlias)(referencer.owner)
            }
        }
        ret tc
    }

    // Builds type, builds result as kind and collects referred type aliases.
    fn buildTypeWithRefers(mut &self, mut &t: &ast::TypeDecl, mut l: Lookup,
        mut generics: []&TypeAlias, mut referencer: &referencer): &TypeKind {
        ret self.typeChecker(l, generics, referencer).checkDecl(t)
    }

    // Checks type, builds result as kind and collects referred type aliases.
    // Skips already checked types.
    fn checkTypeWithRefers(mut &self, mut &t: &TypeSymbol, mut l: Lookup,
        mut generics: []&TypeAlias, mut referencer: &referencer): (ok: bool) {
        if t.checked() {
            ret true
        }
        t.Kind = self.buildTypeWithRefers(t.Decl, l, generics, referencer)
        ret t.checked()
    }

    fn constraintChecker(mut &self): &constraintChecker {
        ret &constraintChecker{s: self}
    }

    // Checks type and builds result as kind.
    // Skips already checked types.
    fn checkType(mut &self, mut &t: &TypeSymbol, mut l: Lookup): bool {
        ret self.checkTypeWithRefers(t, l, nil, nil)
    }

    // Builds type with type aliases for generics.
    // Returns nil if error occur or failed.
    fn buildTypeWithGenerics(mut &self, mut &t: &ast::TypeDecl,
        mut generics: []&TypeAlias, mut refers: &ReferenceStack): &TypeKind {
        let mut tc = &typeChecker{
            s: self,
            rootLookup: self,
            lookup: self,
            useGenerics: generics,
            refers: refers,
        }
        ret tc.checkDecl(t)
    }

    // Same as self.buildTypeWithGenerics but not uses any generics.
    fn buildType(mut &self, mut &t: &ast::TypeDecl): &TypeKind {
        ret self.buildTypeWithGenerics(t, nil, nil)
    }

    // Select type with name selection.
    fn selectType(mut &self, mut &t: &ast::TypeDecl): &TypeKind {
        let mut tc = &typeChecker{
            s: self,
            rootLookup: self,
            lookup: self,
            selection: true,
        }
        ret tc.checkDecl(t)
    }

    // Returns Eval instance for configuration with
    // type prefix and checks var dependencies.
    fn evalpd(mut &self, mut l: Lookup, mut p: &TypeKind, mut owner: &Var): &Eval {
        let mut e = &Eval{
            s: self,
            lookup: l,
            owner: owner,
        }
        match type l {
        | &scopeChecker:
            e.unsafety = (&scopeChecker)(l).isUnsafe()
        }
        e.prefix = p
        ret e
    }

    // Returns Eval instance for configuration with type prefix.
    fn evalp(mut &self, mut l: Lookup, mut p: &TypeKind): &Eval {
        ret self.evalpd(l, p, nil)
    }

    // Returns Eval instance for configuration.
    fn eval(mut &self, mut l: Lookup): &Eval {
        ret self.evalp(l, nil)
    }

    fn checkAssignType(mut &self, destIsRef: bool, mut &dest: &TypeKind,
        mut &d: &Data, mut errorToken: &Token): bool {
        if d.Decl {
            self.pushErr(errorToken, LogMsg.InvalidExpr)
            ret false
        }
        if destIsRef {
            if !dest.Equal(d.Kind) {
                self.pushErr(errorToken, LogMsg.IncompatibleTypes, dest.Str(), d.Kind.Str())
                ret false
            }
        } else {
            let mut atc = &assignTypeChecker{
                s: self,
                errorToken: errorToken,
                dest: dest,
                d: d,
            }
            let ok = atc.check()
            if !ok {
                ret false
            }
        }

        if !d.IsConst() || dest.Prim() == nil {
            ret true
        }

        let mut kind = dest.Prim().Kind

        match {
        | types::IsSigInt(kind):
            d.Constant.SetI64(d.Constant.AsI64())
        | types::IsUnsigInt(kind):
            d.Constant.SetU64(d.Constant.AsU64())
        | types::IsFloat(kind):
            d.Constant.SetF64(d.Constant.AsF64())
        }

        ret true
    }

    fn checkTypeCompatibility(mut &self, mut &dest: &TypeKind,
        mut &src: &TypeKind, mut &errorToken: &Token): bool {
        if src == nil {
            self.pushErr(errorToken, LogMsg.IncompatibleTypes,
                dest.Str(), src.Str())
            ret false
        }

        // Tuple to single type, always fails.
        if src.Tup() != nil {
            self.pushErr(errorToken, LogMsg.IncompatibleTypes,
                dest.Str(), src.Str())
            ret false
        }

        let mut tcc = typeCompatibilityChecker{
            s: self,
            errorToken: errorToken,
            dest: dest,
            src: src,
        }

        if tcc.check() {
            ret true
        }

        self.pushErr(errorToken, LogMsg.IncompatibleTypes, dest.Str(), src.Str())
        ret false
    }

    // Builds non-generic types but skips generic types.
    // Builds generic identifiers as primitive type.
    //
    // Useful:
    //   - For non-generic type parsed string type kinds.
    //   - For checking non-generic types.
    fn buildNonGenericTypeKind(mut &self, mut &ast: &ast::TypeDecl,
        mut &generics: []&ast::GenericDecl, mut &ignored: []&TypeKind): &TypeKind {
        let mut tc = &typeChecker{
            s: self,
            rootLookup: self,
            lookup: self,
            ignoreGenerics: generics,
            ignoredGenerics: &ignored,
        }
        ret tc.checkDecl(ast)
    }

    fn buildFnNonGenericTypeKinds(mut &self, mut &f: &FnIns, mut &ignored: []&TypeKind): (ok: bool) {
        ok = true
        let mut generics: []&ast::GenericDecl = nil
        if f.Decl.IsMethod() {
            generics = append(f.Decl.Generics, f.Decl.Owner.Generics...)
        } else {
            generics = f.Decl.Generics
        }

        for (_, mut p) in f.Params {
            if !p.Decl.IsSelf() {
                p.Kind = self.buildNonGenericTypeKind(p.Decl.Kind.Decl, generics, ignored)
                ok = ok && p.Kind != nil
            }
        }
        if !f.Decl.IsVoid() {
            f.Result = self.buildNonGenericTypeKind(f.Decl.Result.Kind.Decl, generics, ignored)
            ok = ok && f.Result != nil
        }
        ret
    }

    fn getTraitCheckFnKind(mut &self, mut &f: &Fn): &FnIns {
        if len(f.Instances) == 1 {
            ret f.Instances[0]
        }
        let mut ins = f.instanceForce()

        let mut tc = &typeChecker{
            s: self,
            rootLookup: self,
            lookup: self,
        }
        for (_, mut p) in ins.Params {
            if !p.Decl.IsSelf() {
                p.Kind = tc.checkDecl(p.Decl.Kind.Decl)
            }
        }
        if !f.IsVoid() {
            ins.Result = tc.checkDecl(f.Result.Kind.Decl)
        }

        ret ins
    }

    fn checkConstraintsFn(mut &self, mut &f: &FnIns, mut &et: &Token, mut exist: &FnIns): bool {
        let mut cc = self.constraintChecker()
        cc.et = et
        cc.fi = f
        if exist != nil {
            for (i, mut g) in exist.Generics {
                f.Generics[i].Constraint = g.Constraint
            }
        } else {
            cc.uniq = true
        }
        ret cc.check()
    }

    fn checkConstraintsStruct(mut &self, mut &s: &StructIns, mut &et: &Token, mut exist: &StructIns): bool {
        let mut cc = self.constraintChecker()
        cc.et = et
        cc.si = s
        if exist != nil {
            for (i, mut g) in exist.Generics {
                s.Generics[i].Constraint = g.Constraint
            }
        } else {
            cc.uniq = true
        }
        ret cc.check()
    }

    // Call algo in the function's native environment.
    // Errors will be handled.
    // Returns result of algo.
    fn fnEnvironment(mut &self, mut &f: &FnIns, algo: fn(mut &sema: &Sema, mut &generics: []&TypeAlias): bool): bool {
        let mut sema = f.Decl.sema
        let mut old = f.Decl.sema.file
        defer { f.Decl.sema.setCurrentFile(old) }
        let mut file = findFile(f.Decl.sema.files, f.Decl.Token.File)
        if file != nil {
            f.Decl.sema.setCurrentFile(file)
        }

        let mut size = len(f.Generics)
        if f.Decl != nil && f.Decl.Owner != nil {
            size += len(f.Decl.Owner.Generics)
        }

        let mut generics = make([]&TypeAlias, 0, size)
        appendGenericTypeAliases(generics, f)

        let ok = algo(sema, generics)

        if sema != self {
            self.errors = append(self.errors, sema.errors...)
            sema.errors = nil
        }

        ret ok
    }

    fn checkFnParamKind(mut &self, mut &p: &ParamIns) {
        p.Kind.Variadic = p.Decl.Variadic
        if p.Decl.Reference && !isValidForRef(p.Kind) {
            self.pushErr(p.Decl.Token, LogMsg.RefPointsToInvalidType, p.Kind.Str())
        }
    }

    fn reloadFnInsTypes(mut &self, mut f: &FnIns): bool {
        if f.IsBuiltin() || f.IsAnon() {
            ret true
        }
        ret self.fnEnvironment(f, fn(mut &sema: &Sema, mut &generics: []&TypeAlias): bool {
            let mut ok = true
            for (_, mut p) in f.Params {
                if p.Decl.IsSelf() {
                    if p.Decl.IsRef() {
                        p.Kind = &TypeKind{
                            Kind: &Sptr{
                                Elem: &TypeKind{
                                    Kind: f.Owner,
                                },
                            },
                        }
                    } else {
                        p.Kind = &TypeKind{Kind: f.Owner}
                    }
                } else {
                    p.Kind = sema.buildTypeWithGenerics(p.Decl.Kind.Decl, generics, f.Refers)
                    if p.Kind != nil {
                        self.checkFnParamKind(p)
                    } else {
                        ok = false
                    }
                }
            }
            if !f.Decl.IsVoid() {
                f.Result = sema.buildTypeWithGenerics(f.Decl.Result.Kind.Decl, generics, f.Refers)
                ok = f.Result != nil && ok
            }
            ret ok
        })
    }

    fn checkRefValidityForInitExpr(mut &self, leftMut: bool, mut &d: &Data, mut &errorToken: &Token): bool {
        match type d.Model {
        | &Var:
            break
        | &TraitSubIdentExprModel:
            let mut model = (&TraitSubIdentExprModel)(d.Model)
            if !isValidModelForRef(model.Expr) {
                self.pushErr(errorToken, LogMsg.RefIsDangling, model.Method.Ident)
                ret false
            }
        | &StructSubIdentExprModel:
            let mut model = (&StructSubIdentExprModel)(d.Model)
            if !isValidModelForRef(model.Expr.Model) {
                self.pushErr(errorToken, LogMsg.RefIsDangling, model.Field.Decl.Ident)
                ret false
            }
        | &CommonIdentExprModel
        | &CommonSubIdentExprModel:
            self.pushErr(errorToken, LogMsg.BuiltinUsedForRef)
            ret false
        | &UnaryExprModel:
            let mut unary = (&UnaryExprModel)(d.Model)
            if unary.Op.Kind == TokenKind.Star {
                if !isValidModelForRef(d.Model) {
                    self.pushErr(errorToken, LogMsg.RefIsDangling, "address from * &T")
                    ret false
                }
                break
            }
            fall
        |:
            self.pushErr(errorToken, LogMsg.RefAssignNonVar)
            ret false
        }
        if leftMut && !d.Mutable {
            self.pushErr(errorToken, LogMsg.MutRefPointsImmut)
            ret false
        }
        ret true
    }

    fn checkValidityForInitExpr(mut &self, leftMut: bool, leftRef: bool,
        &leftKind: &TypeKind, mut &d: &Data, mut &errorToken: &Token): bool {
        if leftMut && !d.Mutable && d.Kind.Mutable() {
            self.pushErr(errorToken, LogMsg.AssignNonMutToMut, d.Kind.Str())
            ret false
        }
        if leftRef {
            if !self.checkRefValidityForInitExpr(leftMut, d, errorToken) {
                ret false
            }
        }
        let mut atc = &assignTypeChecker{
            s: self,
            d: d,
            errorToken: errorToken,
        }
        ret atc.checkValidity()
    }

    fn checkTypeAliasDeclKind(mut &self, mut &ta: &TypeAlias, mut l: Lookup): (ok: bool) {
        let mut old = self.file
        defer {
            self.setCurrentFile(old)
        }
        if ta.Token != nil {
            let mut file = findFile(self.files, ta.Token.File)
            if file != nil {
                self.setCurrentFile(file)
            }
        }
        ok = self.checkTypeWithRefers(ta.Kind, l, nil, &referencer{
            ident: ta.Ident,
            owner: ta,
            refs: &ta.Refers,
        })
        if ok && ta.Kind.Kind.Arr() != nil && ta.Kind.Kind.Arr().Auto {
            self.pushErr(ta.Kind.Decl.Token, LogMsg.ArrayAutoSized)
            ok = false
        }
        ret
    }

    fn checkTypeAliasDecl(mut &self, mut &ta: &TypeAlias, mut l: Lookup) {
        if IsIgnoreIdent(ta.Ident) {
            self.pushErr(ta.Token, LogMsg.IgnoreIdent)
        }
        self.checkTypeAliasDeclKind(ta, l)
    }

    // Checks type alias declaration with duplicated identifiers.
    fn checkTypeAliasDeclDup(mut &self, mut &ta: &TypeAlias) {
        if IsIgnoreIdent(ta.Ident) {
            self.pushErr(ta.Token, LogMsg.IgnoreIdent)
        }
        if self.isDuplicatedIdent(uintptr(ta), ta.Ident, ta.CppLinked) {
            self.pushErr(ta.Token, LogMsg.DuplicatedIdent, ta.Ident)
            self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
        }
        self.checkTypeAliasDeclKind(ta, self)
    }

    // Checks current package file's type alias declarations.
    fn checkTypeAliasDecls(mut &self): (ok: bool) {
        for (_, mut ta) in self.file.TypeAliases {
            self.checkTypeAliasDeclDup(ta)

            // Break checking if type alias has error.
            if len(self.errors) > 0 {
                ret false
            }
        }
        ret true
    }

    fn checkEnumItemsDup[T](mut self, items: []T) {
        for _, item in items {
            if item.Ident == "" {
                continue
            } else if IsIgnoreIdent(item.Ident) {
                self.pushErr(item.Token, LogMsg.IgnoreIdent)
            } else {
                for _, citem in items {
                    if item == citem {
                        break
                    } else if item.Ident == citem.Ident {
                        self.pushErr(item.Token, LogMsg.DuplicatedIdent, item.Ident)
                        self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
                        break
                    }
                }
            }
        }
    }

    fn checkEnumItemsStr(mut &self, mut &e: &Enum) {
        let mut eval = self.eval(self)
        for (_, mut item) in e.Items {
            if item.AutoExpr() {
                item.Value = &Value{
                    Data: &Data{
                        Constant: Const.NewStr(item.Ident),
                    },
                }
                item.Value.Data.Model = item.Value.Data.Constant
            } else {
                let mut d = eval.evalExpr(item.Value.Expr)
                if d == nil {
                    continue
                }

                if !d.IsConst() {
                    self.pushErr(item.Value.Expr.Token, LogMsg.ExprNotConst)
                }

                _ = self.checkAssignType(false, e.Kind.Kind, d, item.Token)
                item.Value.Data = d
            }
        }
    }

    fn checkEnumItemInt[Int](mut &self, mut &eval: &Eval, mut &e: &Enum, &prim: &Prim, mut &item: &EnumItem, mut &n: Int) {
        if item.AutoExpr() {
            item.Value = &Value{
                Data: new(Data),
            }
            match type Int {
            | i64:
                item.Value.Data.Constant = Const.NewI64(n)
            | u64:
                item.Value.Data.Constant = Const.NewU64(n)
            |:
                panic("unimplemented enum int type, this panic call should be unreachable")
            }
            item.Value.Data.Model = item.Value.Data.Constant
        } else {
            let mut d = eval.evalExpr(item.Value.Expr)
            if d == nil {
                ret
            }
            if !d.IsConst() {
                self.pushErr(item.Value.Expr.Token, LogMsg.ExprNotConst)
            }
            _ = self.checkAssignType(false, e.Kind.Kind, d, item.Token)
            item.Value.Data = d
            match type Int {
            | i64:
                n = item.Value.Data.Constant.ReadI64()
            | u64:
                n = item.Value.Data.Constant.ReadU64()
            |:
                panic("unimplemented enum int type, this panic call should be unreachable")
            }
        }
    }

    fn checkEnumItemsInt1[Int](mut &self, &prim: &Prim, mut &e: &Enum) {
        let mut max: Int = 0
        match type Int {
        | i64:
            max = types::MaxI(prim.Str())
        | u64:
            max = types::MaxU(prim.Str())
        |:
            panic("unimplemented enum int type, this panic call should be unrechable")
        }
        
        let mut eval = self.eval(self)
        let mut n = Int(0)
        let mut first = e.Items[0]
        self.checkEnumItemInt(eval, e, prim, first, n)
        if first.Value.Data != nil {
            match type Int {
            | i64:
                n = first.Value.Data.Constant.AsI64()
            | u64:
                n = first.Value.Data.Constant.AsU64()
            |:
                panic("unimplemented enum int type, this panic call should be unreachable")
            }
        }
        for (_, mut item) in e.Items[1:] {
            if item.AutoExpr() && n > 0 && max-n <= 0 {
                self.pushErr(item.Token, LogMsg.OverflowLimits)
                break
            }
            n++
            self.checkEnumItemInt(eval, e, prim, item, n)
        }
    }

    fn checkEnumItemsInt(mut &self, mut &e: &Enum) {
        let prim = e.Kind.Kind.Prim()
        match {
        | types::IsSigInt(prim.Kind):
            self.checkEnumItemsInt1[i64](prim, e)
        |:
            self.checkEnumItemsInt1[u64](prim, e)
        }
    }

    fn checkEnumDecl(mut &self, mut &e: &Enum) {
        if IsIgnoreIdent(e.Ident) {
            self.pushErr(e.Token, LogMsg.IgnoreIdent)
        } else if self.isDuplicatedIdent(uintptr(e), e.Ident, false) {
            self.pushErr(e.Token, LogMsg.DuplicatedIdent, e.Ident)
            self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
        }

        if len(e.Items) == 0 {
            self.pushErr(e.Token, LogMsg.NoMemberInEnum, e.Ident)
            ret
        }

        self.checkEnumItemsDup[&EnumItem](e.Items)

        if e.Kind != nil {
            if !self.checkType(e.Kind, self) {
                ret
            }
        } else {
            // Set to default type.
            e.Kind = &TypeSymbol{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Int),
                },
            }
        }

        let mut t = e.Kind.Kind.Prim()
        if t == nil {
            self.pushErr(e.Token, LogMsg.InvalidTypeSource)
            ret
        }

        // Check items.
        match {
        | t.IsStr():
            self.checkEnumItemsStr(e)
        | types::IsInt(t.Str()):
            self.checkEnumItemsInt(e)
        |:
            self.pushErr(e.Token, LogMsg.InvalidTypeSource)
        }
    }

    fn checkTypeEnumDecl(mut &self, mut &e: &TypeEnum) {
        if IsIgnoreIdent(e.Ident) {
            self.pushErr(e.Token, LogMsg.IgnoreIdent)
        } else if self.isDuplicatedIdent(uintptr(e), e.Ident, false) {
            self.pushErr(e.Token, LogMsg.DuplicatedIdent, e.Ident)
            self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
        }

        if len(e.Items) == 0 {
            self.pushErr(e.Token, LogMsg.NoMemberInEnum, e.Ident)
            ret
        }

        self.checkEnumItemsDup[&TypeEnumItem](e.Items)
        for (_, mut item) in e.Items {
            if item.Kind == nil {
                self.pushErr(item.Token, LogMsg.MissingType)
                continue
            }
            let ok = self.checkType(item.Kind, self)
            if !ok {
                continue
            }
            let p = item.Kind.Kind.Prim()
            if p != nil && p.IsAny() {
                self.pushErr(item.Token, LogMsg.AnyWithTypeEnum)
            }
        }
        if len(e.Items) == 1 {
            let mut item = e.Items[0]
            let tk = TypeKind{
                Kind: e,
            }
            if item.Kind.Kind != nil && item.Kind.Kind.Equal(unsafe { (&TypeKind)(&tk) }) {
                self.pushErr(item.Token, LogMsg.IllegalCycleRefersItself, e.Str())
            }
        }
    }

    // Checks current package file's enum declarations.
    fn checkEnumDecls(mut &self): (ok: bool) {
        for (_, mut e) in self.file.Enums {
            self.checkEnumDecl(e)
            // Break checking if type alias has error.
            if len(self.errors) > 0 {
                ret false
            }
        }
        ret true
    }

    // Checks current package file's type enum declarations.
    fn checkTypeEnumDecls(mut &self): (ok: bool) {
        for (_, mut e) in self.file.TypeEnums {
            self.checkTypeEnumDecl(e)
            // Break checking if type alias has error.
            if len(self.errors) > 0 {
                ret false
            }
        }
        ret true
    }

    fn checkDeclGenerics(mut self, &generics: []&ast::GenericDecl): (ok: bool) {
        ok = true
        for i, g in generics {
            if IsIgnoreIdent(g.Ident) {
                self.pushErr(g.Token, LogMsg.IgnoreIdent)
                ok = false
                continue
            }

            // Check duplications.
        duplicationLookup:
            for j, ct in generics {
                match {
                | j >= i:
                    // Skip current and following generics.
                    break duplicationLookup
                | g.Ident == ct.Ident:
                    self.pushErr(g.Token, LogMsg.DuplicatedIdent, g.Ident)
                    self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
                    ok = false
                    break duplicationLookup
                }
            }
        }
        ret
    }

    fn checkFnDeclParamsDup(mut self, &f: &Fn): (ok: bool) {
        ok = true
    check:
        for i, p in f.Params {
            // Lookup in generics.
            for _, g in f.Generics {
                if p.Ident == g.Ident {
                    ok = false
                    self.pushErr(p.Token, LogMsg.DuplicatedIdent, p.Ident)
                    self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
                    continue check
                }
            }

        paramsLookup:
            for j, jp in f.Params {
                match {
                | j >= i:
                    // Skip current and following parameters.
                    break paramsLookup
                | IsIgnoreIdent(p.Ident)
                | IsIgnoreIdent(jp.Ident)
                | IsAnonIdent(p.Ident)
                | IsAnonIdent(jp.Ident):
                    // Skip anonymous parameters.
                    break paramsLookup
                | p.Ident == jp.Ident:
                    ok = false
                    self.pushErr(p.Token, LogMsg.DuplicatedIdent, p.Ident)
                    self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
                    continue check
                }
            }
        }
        ret
    }

    fn checkFnDeclResultDup(mut self, &f: &Fn): (ok: bool) {
        ok = true
        if f.IsVoid() {
            ret
        }

        // Check duplications.
        for i, v in f.Result.Idents {
            if IsIgnoreIdent(v.Kind) || IsAnonIdent(v.Kind) {
                continue // Skip anonymous return variables.
            }
            // Lookup in generics.
            for _, g in f.Generics {
                if v.Kind == g.Ident {
                    goto exist
                }
            }
            // Lookup in parameters.
            for _, p in f.Params {
                if v.Kind == p.Ident {
                    goto exist
                }
            }

            // Lookup in return identifiers.
        itself_lookup:
            for j, jv in f.Result.Idents {
                match {
                | j >= i:
                    // Skip current and following identifiers.
                    break itself_lookup
                | jv.Kind == v.Kind:
                    goto exist
                }
            }
            continue
        exist:
            self.pushErr(v, LogMsg.DuplicatedIdent, v.Kind)
            self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
            ok = false
        }

        ret
    }

    // Checks generics, parameters and return type.
    // Not checks scope, and other things.
    fn checkFnDeclPrototype(mut &self, mut &f: &Fn) {
        if f.Exceptional && f.CppLinked {
            self.pushErr(f.Token, LogMsg.CDefineExceptional)
            ret
        }

        if f.Exceptional {
            if f.IsEntryPoint() {
                self.pushErr(f.Token, LogMsg.ExceptionalEntryPoint)
            } else if f.IsInit() {
                self.pushErr(f.Token, LogMsg.ExceptionalInit)
            }
        }

        match {
        | !self.checkDeclGenerics(f.Generics):
        | !self.checkFnDeclParamsDup(f):
        | !self.checkFnDeclResultDup(f):
        }
    }

    fn catchTraitInheritCycle(mut &self, t1: &Trait, mut t2: &Trait, mut &message: str): (ok: bool) {
        ok = true
        for (_, mut i) in t2.Inherits {
            if i.Kind == nil {
                continue
            }
            let mut t3 = i.Kind.Trait()
            if t1 == t3 {
                self.pushCycleError(t2.Ident, t3.Ident, message)
                ret false
            }
            if !self.catchTraitInheritCycle(t1, t3, message) {
                self.pushCycleError(t2.Ident, t3.Ident, message)
                ret false
            }
        }
        ret
    }

    fn _checkTraitDeclInherits(mut &self, mut &t: &Trait): (ok: bool) {
        ok = true
        for (i, mut it) in t.Inherits {
            if !self.checkType(it, self) {
                ok = false
                continue
            }
            let mut t2 = it.Kind.Trait()
            if t2 == nil {
                self.pushErr(it.Decl.Token, LogMsg.InheritedNonTrait, t.Ident, it.Kind.Str())
                ok = false
                continue
            }
            for j, it2 in t.Inherits {
                if j >= i {
                    break
                }
                if it2.Kind != nil && it.Kind.Equal(it2.Kind) {
                    self.pushErr(it.Decl.Token, LogMsg.DuplicatedIdent, t2.Ident)
                    ok = false
                    break
                }
            }
            if t == t2 {
                self.pushErr(it.Decl.Token, LogMsg.IllegalCycleRefersItself, t.Ident)
                ok = false
            } else {
                let mut message = ""
                ok = ok && self.catchTraitInheritCycle(t, t2, message)
                if len(message) > 0 {
                    let mut errMsg = message
                    message = ""
                    self.pushCycleError(t.Ident, t2.Ident, message)
                    errMsg += message
                    self.pushErr(it.Decl.Token, LogMsg.IllegalCrossCycle, errMsg)
                }
            }
        }
        ret ok
    }

    fn checkTraitDeclInherits(mut &self, mut &t: &Trait) {
        for (i, mut it) in t.Inherits {
            let mut t1 = it.Kind.Trait()
            for (j, mut it2) in t.Inherits {
                if j == i {
                    continue
                }
                let mut t2 = it2.Kind.Trait()
                for (_, mut t1m) in t1.Methods {
                    let mut t2m = t2.FindMethod(t1m.Ident)
                    if t2m == nil {
                        continue
                    }
                    let t1f = self.getTraitCheckFnKind(t1m)
                    let t2f = self.getTraitCheckFnKind(t2m)
                    if !t1f.equalTrait(t2f) {
                        self.pushErr(it.Decl.Token, LogMsg.IncompatibleInherit,
                            t.Ident, t2.Ident, t1f.GetKindStr(true), t2f.GetKindStr(true))
                        ret
                    }
                }
            }
        }
    }

    fn checkTraitDeclMethod(mut &self, mut &f: &Fn) {
        if IsIgnoreIdent(f.Ident) {
            self.pushErr(f.Token, LogMsg.IgnoreIdent)
        }
        f.sema = self
        self.checkFnDeclPrototype(f)
        let mut ins = f.instance()
        _ = self.reloadFnInsTypes(ins)
        ins.reloaded = true
        f.appendInstance(ins)
    }

    fn checkTraitDeclMethods(mut &self, mut &t: &Trait) {
        for (i, mut f) in t.Methods {
            self.checkTraitDeclMethod(f)
            t.Mutable = t.Mutable || f.Params[0].Mutable

            // Break checking if type alias has error.
            if len(self.errors) > 0 {
                ret
            }

            if t.findMethodInherit(f.Ident) != nil {
                self.pushErr(f.Token, LogMsg.DuplicatedIdent, f.Ident)
                self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
                continue
            }

            // Check duplications.
        duplicateLookup:
            for j, jf in t.Methods {
                // NOTE:
                //  Ignore identifier checking is unnecessary here.
                //  Because ignore identifiers logs error.
                //  Errors breaks checking, so here is unreachable code for
                //  ignore identified methods.
                match {
                | j >= i:
                    // Skip current and following methods.
                    break duplicateLookup
                | f.Ident == jf.Ident:
                    self.pushErr(f.Token, LogMsg.DuplicatedIdent, f.Ident)
                    self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
                    break duplicateLookup
                }
            }
        }
    }

    fn checkTraitDecl(mut &self, mut &t: &Trait) {
        if IsIgnoreIdent(t.Ident) {
            self.pushErr(t.Token, LogMsg.IgnoreIdent)
        } else if self.isDuplicatedIdent(uintptr(t), t.Ident, false) {
            self.pushErr(t.Token, LogMsg.DuplicatedIdent, t.Ident)
            self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
        }

        self.checkTraitDeclInherits(t)
        self.checkTraitDeclMethods(t)
    }

    // Checks current package file's trait declarations.
    fn checkTraitDecls(mut &self): (ok: bool) {
        for (_, mut t) in self.file.Traits {
            self.checkTraitDecl(t)
            // Break checking if type alias has error.
            if len(self.errors) > 0 {
                ret false
            }
        }
        ret true
    }

    fn checkTraitImplMethods(mut self, mut &base: &Trait, &ipl: &Impl): (ok: bool) {
        ok = true
        for _, f in ipl.Methods {
            if base.FindMethod(f.Ident) == nil {
                self.pushErr(f.Token, LogMsg.TraitHaveNotIdent, base.Ident, f.Ident)
                ok = false
            }
        }
        ret
    }

    fn implToStruct(mut &self, mut &dest: &Struct, mut &ipl: &Impl): (ok: bool) {
        ok = true

        // Methods.
        for (_, mut f) in ipl.Methods {
            if dest.FindMethod(f.Ident, f.Statically) != nil || dest.FindField(f.Ident) != nil {
                self.pushErr(f.Token, LogMsg.StructAlreadyHaveIdent, dest.Ident, f.Ident)
                ok = false
                continue
            }

            if len(dest.Generics) > 0 && len(f.Generics) > 0 {
                for _, fg in f.Generics {
                    for _, dg in dest.Generics {
                        if fg.Ident == dg.Ident {
                            self.pushErr(fg.Token, LogMsg.MethodHasGenericWithSameIdent)
                            ok = false
                        }
                    }
                }
            }

            self.checkDirectives(f.Directives, f)

            f.sema = self
            f.Owner = dest
            dest.Methods = append(dest.Methods, f)
        }

        for (_, mut v) in ipl.Statics {
            const Static = true
            if dest.FindMethod(v.Ident, Static) != nil || dest.FindStatic(v.Ident) != nil {
                self.pushErr(v.Token, LogMsg.StructAlreadyHaveIdent, dest.Ident, v.Ident)
                ok = false
                continue
            }
            dest.Statics = append(dest.Statics, v)
        }
        ret
    }

    // Implement trait to destination.
    fn implTrait(mut &self, mut &decl: &Impl) {
        let mut base_t = self.selectType(decl.Base)
        if base_t == nil {
            ret
        }
        let mut base = base_t.Trait()
        if base == nil {
            self.pushErr(decl.Base.Token, LogMsg.ImplInvalidBase, base_t.Str())
            self.pushSugggestion(LogMsg.ExpectedTrait)
            ret
        }

        let mut destT = self.selectType(decl.Dest)
        if destT == nil {
            ret
        }
        let mut destS = destT.Struct()
        if destS == nil {
            self.pushErr(decl.Dest.Token, LogMsg.ImplInvalidDest, destT.Str())
            self.pushSugggestion(LogMsg.ExpectedStruct)
            ret
        }

        let mut dest = destS.Decl

        if dest.Token.File.Dir() != self.file.File.Dir() {
            self.pushErr(decl.Dest.Token, LogMsg.IllegalImplOutOfPackage)
            ret
        }

        pushImplemented(base, dest)
        pushImplements(dest, base)

        if len(decl.Statics) > 0 {
            self.pushErr(decl.Statics[0].Token, LogMsg.TraitImplHasStatic)
        }

        match {
        | !self.checkTraitImplMethods(base, decl):
            ret
        | !self.implToStruct(dest, decl):
            ret
        }
    }

    fn implStruct(mut &self, mut &decl: &Impl) {
        let mut destT = self.selectType(decl.Dest)
        if destT == nil {
            ret
        }
        let mut destS = destT.Struct()
        if destS == nil {
            self.pushErr(decl.Dest.Token, LogMsg.ImplInvalidDest, destT.Str())
            self.pushSugggestion(LogMsg.ExpectedStruct)
            ret
        }

        let mut dest = destS.Decl
        if dest.Token.File.Dir() != self.file.File.Dir() {
            self.pushErr(decl.Dest.Token, LogMsg.IllegalImplOutOfPackage)
            ret
        }

        match {
        | !self.implToStruct(dest, decl):
            ret
        }
    }

    // Implement implementation.
    fn implImpl(mut &self, mut &decl: &Impl) {
        match {
        | decl.IsTraitImpl():
            self.implTrait(decl)
        | decl.IsStructImpl():
            self.implStruct(decl)
        }
    }

    // Checks variable declaration.
    // No checks duplicated identifiers.
    fn checkVarDecl(mut &self, mut &decl: &Var, mut l: Lookup) {
        if IsIgnoreIdent(decl.Ident) {
            self.pushErr(decl.Token, LogMsg.IgnoreIdent)
        }

        if decl.IsTypeInferred() {
            if !decl.IsInitialized() {
                self.pushErr(decl.Token, LogMsg.MissingValueForTypeInference)
            }
        } else {
            _ = self.checkType(decl.Kind, l)
        }

        if decl.Constant && decl.Reference {
            self.pushErr(decl.Token, LogMsg.ConstRef)
        }

        if !decl.IsInitialized() {
            if decl.Constant {
                self.pushErr(decl.Token, LogMsg.ConstVarNotHaveExpr)
            }
            if decl.Statically {
                self.pushErr(decl.Token, LogMsg.StaticNotHaveExpr)
            }
            if decl.Reference {
                self.pushErr(decl.Token, LogMsg.RefNotInited)
            }
        }
    }

    // Checks variable declaration for global scope.
    // Checks duplicated identifiers by Sema.
    fn checkGlobalVarDecl(mut &self, mut &decl: &Var) {
        if self.isDuplicatedIdent(uintptr(decl), decl.Ident, decl.CppLinked) {
            self.pushErr(decl.Token, LogMsg.DuplicatedIdent, decl.Ident)
            self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
        }
        if decl.CppLinked && decl.Constant {
            self.pushErr(decl.Token, LogMsg.CppLinkedVarIsConst)
        }
        if !decl.CppLinked && !decl.Constant && !decl.Statically {
            self.pushErr(decl.Token, LogMsg.GlobalNotStatic)
            self.pushSugggestion(LogMsg.UseStaticKeywordToDef)
        }
        self.checkDirectives(decl.Directives, decl)
        self.checkVarDecl(decl, self)
    }

    // Checks current package file's global variable declarations.
    fn checkGlobalDecls(mut &self): (ok: bool) {
        for (_, mut decl) in self.file.Vars {
            self.checkGlobalVarDecl(decl)
            // Break checking if type alias has error.
            if len(self.errors) > 0 {
                ret false
            }
        }
        ret true
    }

    fn checkStructTraitImpl(mut &self, mut &strct: &Struct, mut &trt: &Trait): (ok: bool) {
        for (_, mut tf) in trt.Methods {
            let mut exist = false
            let mut sf = strct.FindMethod(tf.Ident, tf.Statically)
            let tfK = self.getTraitCheckFnKind(tf)
            if sf != nil {
                let mut sfK = self.getTraitCheckFnKind(sf)
                exist = tfK.equalTrait(sfK)
            }
            if exist {
                let d = findDirective(sf.Directives, Directive.Deprecated)
                if d != nil {
                    self.pushErr(d.Tag, LogMsg.TraitImplDeprecated)
                }
                ok = false
            } else {
                const Ident = true
                self.pushErr(strct.Token, LogMsg.NotImplTraitDef, trt.Ident, tfK.GetKindStr(Ident))
                ok = false
            }
        }
        ret
    }

    fn checkStructImpls(mut &self, mut &s: &Struct): (ok: bool) {
        ok = true
        for (_, mut trt) in s.Implements {
            ok = self.checkStructTraitImpl(s, trt) && ok
        }
        ret ok
    }

    fn checkStructFields(mut &self, mut &st: &Struct): (ok: bool) {
        ok = true
        for (_, mut f) in st.Fields {
            f.Owner = st
            for _, cf in st.Fields {
                if f == cf {
                    break
                } else if f.Ident == cf.Ident {
                    self.pushErr(f.Token, LogMsg.DuplicatedIdent, f.Ident)
                    self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
                    ok = false
                }
            }
        }
        ret ok
    }

    fn checkStructDecl(mut &self, mut &s: &Struct) {
        if IsIgnoreIdent(s.Ident) {
            self.pushErr(s.Token, LogMsg.IgnoreIdent)
        } else if self.isDuplicatedIdent(uintptr(s), s.Ident, s.CppLinked) {
            self.pushErr(s.Token, LogMsg.DuplicatedIdent, s.Ident)
            self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
        }

        self.checkDirectives(s.Directives, s)

        match {
        | !self.checkDeclGenerics(s.Generics):
        | !self.checkStructFields(s):
        | !self.checkStructImpls(s):
        }
    }

    // Checks current package file's structure declarations.
    fn checkStructDecls(mut &self): (ok: bool) {
        for (_, mut s) in self.file.Structs {
            self.checkStructDecl(s)
            // Break checking if type alias has error.
            if len(self.errors) > 0 {
                ret false
            }
        }
        ret true
    }

    fn checkFnDecl(mut &self, mut &f: &Fn) {
        if IsIgnoreIdent(f.Ident) {
            self.pushErr(f.Token, LogMsg.IgnoreIdent)
        }

        self.checkDirectives(f.Directives, f)

        f.sema = self
        self.checkFnDeclPrototype(f)

        if self.isDuplicatedIdent(uintptr(f), f.Ident, f.CppLinked) {
            if f.Ident == build::InitFn {
                let init = self.FindFn(build::InitFn, false)
                if init != nil {
                    ret
                }
            }
            self.pushErr(f.Token, LogMsg.DuplicatedIdent, f.Ident)
            self.pushSugggestion(LogMsg.RenameForAvoidDuplication)
        }
    }

    // Checks current package file's function declarations.
    fn checkFnDecls(mut &self): (ok: bool) {
        for (_, mut f) in self.file.Funcs {
            self.checkFnDecl(f)
            // Break checking if type alias has error.
            if len(self.errors) > 0 {
                ret false
            }
        }
        ret true
    }

    fn pushCycleError(self, &st1: str, &st2: str, mut &message: str) {
        const Padding = 7
        let refers_to = Logf(LogMsg.RefersTo, st1, st2)
        message = strings::Repeat(" ", Padding) + refers_to + "\n" + message
    }

    fn checkCrossCycle(self, &st1: &Struct, &st2: &Struct, mut &message: str): bool {
        for _, u in st2.Uses {
            if u == st1 {
                self.pushCycleError(st2.Ident, u.Ident, message)
                ret false
            }
            if !self.checkCrossCycle(st1, u, message) {
                self.pushCycleError(st2.Ident, u.Ident, message)
                ret false
            }
        }
        ret true
    }

    fn checkStructDeriveIllegalCycles(mut self, derive: str, &st1: &Struct, mut &k: &TypeKind): (ok: bool) {
        let mut st2 = getStructFromKind(k)
        if st2 == nil {
            ret true
        }

        // Check illegal cycle for itself.
        // Because refers's owner is ta.
        if st1 == st2 {
            self.pushErr(st1.Token, LogMsg.DeriveIllegalCycleRefersItself, derive, st1.Ident)
            ret false
        }

        let mut message = ""
        if !self.checkCrossCycle(st1, st2, message) {
            let mut errMsg = message
            message = ""
            self.pushCycleError(st1.Ident, st2.Ident, message)
            errMsg += message
            self.pushErr(st1.Token, LogMsg.DeriveIllegalCrossCycle, derive, errMsg)
            ret false
        }
        ret true
    }

    fn checkStructInsDeriveClone(mut self, mut st: &StructIns): (ok: bool) {
        if !st.Decl.IsDerives(Derive.Clone) {
            ret true
        }
        for (_, mut f) in st.Fields {
            if f.Kind == nil {
                continue
            }
            if !f.Kind.SupportsCloning() {
                self.pushErr(st.Decl.Token, LogMsg.TypeNotCompatibleForDerive, f.Kind.Str(), Derive.Clone)
                ret false
            }
            if !self.checkStructDeriveIllegalCycles(Derive.Clone, st.Decl, f.Kind) {
                ret false
            }
        }
        ret true
    }

    // Checks declarations of all package files.
    // Breaks checking if checked file failed.
    fn checkPackageDecls(mut &self) {
        for (_, mut f) in self.files {
            self.setCurrentFile(f)
            if !self.checkTypeEnumDecls() {
                ret
            }
            if !self.checkTypeAliasDecls() {
                ret
            }
        }

        for (_, mut f) in self.files {
            self.setCurrentFile(f)
            if !self.checkTraitDecls() {
                ret
            }
        }

        for (_, mut f) in self.files {
            self.setCurrentFile(f)
            if !self.checkGlobalDecls() {
                ret
            }
        }

        for (_, mut f) in self.files {
            self.setCurrentFile(f)
            match {
            | !self.checkFnDecls():
            | !self.checkStructDecls():
            |:
                continue
            }
            ret
        }
    }

    fn checkDataForTypeInference(mut self, &d: &Data, &err_token: &Token) {
        match {
        | d.IsNil():
            self.pushErr(err_token, LogMsg.NilForTypeInference)
        | d.IsVoid():
            self.pushErr(err_token, LogMsg.VoidForTypeInference)
        | d.Kind.Variadic:
            self.pushErr(err_token, LogMsg.InvalidExprForTypeInference)
        }
    }

    fn checkVar(mut &self, mut &v: &Var) {
        if v.CppLinked {
            ret
        }

        if v.IsTypeInferred() {
            // Build new TypeSymbol because auto-type symbols are nil.
            v.Kind = &TypeSymbol{Kind: v.Value.Data.Kind}

            self.checkDataForTypeInference(v.Value.Data, v.Value.Expr.Token)
            self.checkValidityForInitExpr(
                v.Mutable,
                v.Reference,
                v.Kind.Kind,
                v.Value.Data,
                v.Value.Expr.Token)
        } else {
            let mut arr = v.Kind.Kind.Arr()
            if arr != nil {
                if arr.Auto {
                    let dataArr = v.Value.Data.Kind.Arr()
                    if dataArr != nil {
                        arr.N = dataArr.N
                    }
                }
            }

            if self.checkAssignType(v.Reference, v.Kind.Kind, v.Value.Data, v.Value.Expr.Token) {
                self.checkValidityForInitExpr(
                    v.Mutable,
                    v.Reference,
                    v.Kind.Kind,
                    v.Value.Data,
                    v.Value.Expr.Token)
            }
        }

        if v.Reference && !isValidForRef(v.Kind.Kind) {
            self.pushErr(v.Token, LogMsg.RefPointsToInvalidType, v.Kind.Kind.Str())
        }

        if v.Constant {
            if !v.Value.Data.IsConst() {
                self.pushErr(v.Value.Expr.Token, LogMsg.ExprNotConst)
            }
        } else {
            v.Value.Data.Constant = nil
        }

        // Remove kind for avoid more tuple-type errors.
        if v.Kind.Kind.Tup() != nil {
            v.Kind.Kind = nil
        }
    }

    fn checkTypeVar(mut &self, mut &decl: &Var, mut l: Lookup) {
        if decl.CppLinked || !decl.IsInitialized() {
            ret
        }

        let mut eval: &Eval = nil
        if decl.Kind != nil {
            eval = self.evalpd(l, decl.Kind.Kind, decl)
        } else {
            eval = self.evalpd(l, nil, decl)
        }
        eval.immutable = !decl.Mutable
        decl.Value.Data = eval.evalExpr(decl.Value.Expr)
        if decl.Value.Data == nil {
            ret // Skip checks if error ocurrs.
        }
        self.checkVar(decl)
    }

    // Checks types of current package file's global variables.
    fn checkGlobalTypes(mut &self) {
        for (_, mut decl) in self.file.Vars {
            if decl.IsInitialized() && decl.Value.Data == nil ||
                decl.IsTypeInferred() && decl.Kind.Kind == nil {
                self.checkTypeVar(decl, self)
            }
        }
    }

    // Returns new FnIns as ready-to-analysis.
    // If function already has a instance, returns existing instance.
    // Returns nil if have a problem.
    fn readyToCheckFn(mut &self, mut &s: &StructIns, mut &f: &Fn): &FnIns {
        let mut ins = f.instance()
        if len(f.Instances) != 0 {
            ret ins
        }
        ins.Owner = s
        f.appendInstance(ins)
        ins.reloaded = true
        if self.reloadFnInsTypes(ins) {
            ret ins
        }
        ret nil
    }

    fn checkTypeMethod(mut &self, mut &s: &StructIns, mut &f: &Fn) {
        // Generic instances are checked instantly.
        if len(f.Generics) > 0 {
            ret
        }
        let mut ins = f.Instances[0]
        if len(ins.Scope.Stmts) > 0 {
            // Checked
            ret
        }
        self.checkFnIns(ins)
    }

    fn checkStructInsOp(mut &self, mut &s: &StructIns, mut &f: &Fn, p: fn(f: &Fn): bool): &FnIns {
        if f == nil || len(f.Generics) > 0 || !p(f) {
            ret nil
        }
        ret f.Instances[0]
    }

    // Checks environment-dependent parts of structure instance.
    // Which is contains fields and generic-type constraints.
    // If generic instance will be check, errorToken should be passed.
    fn checkStructEnv(mut &self, mut &s: &StructIns, mut errorToken: &Token): (ok: bool) {
        let mut tc = typeChecker{
            s: s.Decl.sema,
            rootLookup: s.Decl.sema,
            lookup: s.Decl.sema,
            referencer: &referencer{
                ident: s.Decl.Ident,
                owner: s.Decl,
            },
            refers: s.Refers,
        }

        if len(s.Generics) > 0 {
            tc.useGenerics = make([]&TypeAlias, 0, len(s.Generics))
            for (i, mut g) in s.Generics {
                let mut decl = s.Decl.Generics[i]
                tc.useGenerics = append(tc.useGenerics, &TypeAlias{
                    Ident: decl.Ident,
                    Token: decl.Token,
                    Kind: &TypeSymbol{Kind: g.Kind},
                })
            }
        }

        let mut oldFile = self.file
        defer { self.setCurrentFile(oldFile) }

        if self.file.File != s.Decl.Token.File {
            let mut file = findFile(self.files, s.Decl.Token.File)
            if file != nil {
                self.setCurrentFile(file)
            }
        }

        if len(s.Generics) > 0 {
            let mut cc = self.constraintChecker()
            cc.et = errorToken
            cc.si = s
            cc.genericsA = tc.useGenerics
            cc.uniq = true
            if !cc.check() {
                ret
            }
        }

        ok = true

        if len(s.Statics) > 0 {
            let mut n = len(self.errors)
            self.files[0].TypeAliases = append(tc.useGenerics, self.files[0].TypeAliases...)
            for (_, mut v) in s.Statics {
                self.checkVarDecl(v, self)
                self.checkTypeVar(v, self)
                ok = len(self.errors)-n == 0 && ok
            }
            self.files[0].TypeAliases = self.files[0].TypeAliases[len(tc.useGenerics):]
            if !ok {
                ret false
            }
        }

        let mut eval = self.eval(self)
        s.Comparable = !s.Decl.CppLinked
        for (_, mut f) in s.Fields {
            let mut kind = tc.checkDecl(f.Decl.Kind.Decl)
            ok = kind != nil && ok
            if kind == nil {
                if self != s.Decl.sema && len(s.Decl.sema.errors) > 0 {
                    self.errors = append(self.errors, s.Decl.sema.errors...)
                    s.Decl.sema.errors = nil
                }
                continue
            }
            f.Kind = kind
            s.Mutable = s.Mutable || (!f.Decl.Mutable && f.Kind.Mutable())
            s.Comparable = s.Comparable && f.Kind.Comparable()
            _ = self.checkStructInsDeriveClone(s)

            // Skip this field if not has default value.
            if f.Decl.Default == nil {
                continue
            }
            eval.prefix = f.Kind
            eval.field = f
            f.Default = eval.evalExpr(f.Decl.Default)

            // Skip if eval returned nil.
            // Relevant error(s) logged by eval.
            if f.Default == nil {
                continue
            }

            const Reference = false // Fields cannot be reference.
            _ = self.checkAssignType(Reference, f.Kind, f.Default, f.Decl.Default.Token)
        }
        ret
    }

    fn precheckStructIns(mut &self, mut &s: &StructIns, mut errorToken: &Token): (ok: bool) {
        ok = self.checkStructEnv(s, errorToken)
        if !ok {
            ret false
        }
        for (_, mut f) in s.Methods {
            if len(f.Generics) == 0 {
                if self.readyToCheckFn(s, f) == nil {
                    ret false
                }
            }
        }
        ret true
    }

    fn checkStructIns(mut &self, mut &s: &StructIns) {
        for (_, mut f) in s.Methods {
            self.checkTypeMethod(s, f)
        }
    }

    fn checkTypeStruct(mut &self, mut &s: &Struct) {
        if s.CppLinked {
            ret
        }

        // Generic instances are checked instantly.
        if len(s.Generics) > 0 {
            ret
        }

        // NOTICE:
        // Do not check zero instance case, operator overloading
        // checker will create an instance if not exist.
        for (_, mut ins) in s.Instances {
            self.checkStructIns(ins)
        }
    }

    fn checkStructTypes(mut &self) {
        for (_, mut s) in self.file.Structs {
            self.checkTypeStruct(s)
        }
    }

    fn checkStructInsOperators(mut &self, mut s: &StructIns) {
        for (_, mut m) in s.Methods {
            match m.Ident {
            | "Eq":
                s.Operators.Eq = self.checkStructInsOp(s, m, FuncPattern.Eq)
                s.Comparable = s.Operators.Eq != nil
            | "Gt":
                s.Operators.Gt = self.checkStructInsOp(s, m, FuncPattern.Gt)
            | "GtEq":
                s.Operators.GtEq = self.checkStructInsOp(s, m, FuncPattern.GtEq)
            | "Lt":
                s.Operators.Lt = self.checkStructInsOp(s, m, FuncPattern.Lt)
            | "LtEq":
                s.Operators.LtEq = self.checkStructInsOp(s, m, FuncPattern.LtEq)
            | "Shl":
                s.Operators.Shl = self.checkStructInsOp(s, m, FuncPattern.Shl)
            | "Shr":
                s.Operators.Shr = self.checkStructInsOp(s, m, FuncPattern.Shr)
            | "Add":
                s.Operators.Add = self.checkStructInsOp(s, m, FuncPattern.Add)
            | "Sub":
                s.Operators.Sub = self.checkStructInsOp(s, m, FuncPattern.Sub)
            | "Div":
                s.Operators.Div = self.checkStructInsOp(s, m, FuncPattern.Div)
            | "Mul":
                s.Operators.Mul = self.checkStructInsOp(s, m, FuncPattern.Mul)
            | "Mod":
                s.Operators.Mod = self.checkStructInsOp(s, m, FuncPattern.Mod)
            | "BitAnd":
                s.Operators.BitAnd = self.checkStructInsOp(s, m, FuncPattern.BitAnd)
            | "BitOr":
                s.Operators.BitOr = self.checkStructInsOp(s, m, FuncPattern.BitOr)
            | "BitXor":
                s.Operators.BitXor = self.checkStructInsOp(s, m, FuncPattern.BitXor)
            | "Neg":
                s.Operators.Neg = self.checkStructInsOp(s, m, FuncPattern.Neg)
            | "Pos":
                s.Operators.Pos = self.checkStructInsOp(s, m, FuncPattern.Pos)
            | "BitNot":
                s.Operators.BitNot = self.checkStructInsOp(s, m, FuncPattern.BitNot)
            | "AddAssign":
                s.Operators.AddAssign = self.checkStructInsOp(s, m, FuncPattern.AddAssign)
            | "SubAssign":
                s.Operators.SubAssign = self.checkStructInsOp(s, m, FuncPattern.SubAssign)
            | "DivAssign":
                s.Operators.DivAssign = self.checkStructInsOp(s, m, FuncPattern.DivAssign)
            | "MulAssign":
                s.Operators.MulAssign = self.checkStructInsOp(s, m, FuncPattern.MulAssign)
            | "ModAssign":
                s.Operators.ModAssign = self.checkStructInsOp(s, m, FuncPattern.ModAssign)
            | "ShlAssign":
                s.Operators.ShlAssign = self.checkStructInsOp(s, m, FuncPattern.ShlAssign)
            | "ShrAssign":
                s.Operators.ShrAssign = self.checkStructInsOp(s, m, FuncPattern.ShrAssign)
            | "BitOrAssign":
                s.Operators.BitOrAssign = self.checkStructInsOp(s, m, FuncPattern.BitOrAssign)
            | "BitAndAssign":
                s.Operators.BitAndAssign = self.checkStructInsOp(s, m, FuncPattern.BitAndAssign)
            | "BitXorAssign":
                s.Operators.BitXorAssign = self.checkStructInsOp(s, m, FuncPattern.BitXorAssign)
            }
        }
    }

    fn precheckStructType(mut &self, mut &s: &Struct) {
        if s.CppLinked {
            ret
        }

        // Generic instances are checked instantly.
        if len(s.Generics) > 0 {
            ret
        }

        if len(s.Instances) == 0 {
            let mut ins = s.instance()
            ins.Checked = true
            s.appendInstance(ins) // Append instance before precheck.
            self.precheckStructIns(ins, nil)
        }

        self.checkStructInsOperators(s.Instances[0])
    }

    fn precheckStructTypes(mut &self) {
        for (_, mut s) in self.file.Structs {
            self.precheckStructType(s)
        }
    }

    fn checkRets(mut self, mut &f: &FnIns) {
        if f.Decl.IsVoid() {
            ret
        }
        let mrc = missingRetChecker.new()
        let ok = mrc.check(f.Scope)
        if !ok {
            self.pushErr(f.Decl.Token, LogMsg.MissingRet)
        }
    }

    fn checkFnInsSc(mut self, mut &f: &FnIns, mut &sc: &scopeChecker) {
        appendRetVars(sc.table.Vars, f)
        appendParamVars(sc.table.Vars, f)
        appendGenericTypeAliases(sc.table.TypeAliases, f)

        sc.check(f.Decl.Scope, f.Scope)

        // Check return statements if scopeChecker not forced to stop.
        if !sc.stopped() {
            self.checkRets(f)
        }
    }

    fn checkFnInsCaller(mut &self, mut &f: &FnIns, mut caller: &Token) {
        if f.Decl.CppLinked {
            ret
        }

        let mut old = f.Decl.sema.file
        defer { f.Decl.sema.setCurrentFile(old) }
        let mut file = findFile(f.Decl.sema.files, f.Decl.Token.File)
        if file != nil {
            f.Decl.sema.setCurrentFile(file)
        }

        let mut sc = newScopeChecker(f.Decl.sema, f)
        sc.calledFrom = caller
        self.checkFnInsSc(f, sc)

        if f.Decl.sema != self {
            self.errors = append(self.errors, f.Decl.sema.errors...)
            f.Decl.sema.errors = nil
        }
    }

    fn checkFnIns(mut &self, mut &f: &FnIns) {
        self.checkFnInsCaller(f, nil)
    }

    fn checkTypeFn(mut &self, mut &f: &Fn) {
        if f.CppLinked {
            ret
        }

        // Generic instances are checked instantly.
        if len(f.Generics) > 0 {
            ret
        }

        for (_, mut ins) in f.Instances {
            self.checkFnIns(ins)
        }
    }

    fn checkTestFn(mut self, mut &f: &FnIns) {
        if f.Decl.Public {
            self.pushErr(f.Decl.Token, LogMsg.PubTestFn)
            self.pushSugggestion(LogMsg.RemovePubModifier)
            ret
        }

        if f.Decl.Unsafety ||
            !f.Decl.IsVoid() ||
            len(f.Decl.Generics) != 0 ||
            len(f.Params) != 1 ||
            f.Decl.Params[0].Mutable ||
            f.Decl.Params[0].Reference {
            self.pushErr(f.Decl.Token, LogMsg.WrongTestFnDecl)
            self.pushSugggestion(LogMsg.UseExpectedTestFnDecl)
            ret
        }

        let mut sptr = f.Params[0].Kind.Sptr()
        if sptr == nil {
            self.pushErr(f.Decl.Token, LogMsg.WrongTestFnDecl)
            self.pushSugggestion(LogMsg.UseExpectedTestFnDecl)
            ret
        }

        let s = sptr.Elem.Struct()
        if s == nil || !isStdPackage(s.Decl.Token.File.Path, "testing") {
            self.pushErr(f.Decl.Token, LogMsg.WrongTestFnDecl)
            self.pushSugggestion(LogMsg.UseExpectedTestFnDecl)
            ret
        }
    }

    fn precheckTypeFn(mut &self, mut &f: &Fn) {
        if f.CppLinked {
            ret
        }

        // Generic instances are checked instantly.
        if len(f.Generics) > 0 {
            ret
        }

        if len(f.Instances) == 0 {
            let mut ins = f.instanceForce()
            f.Instances = append(f.Instances, ins)
            let ok = self.reloadFnInsTypes(ins)
            ins.reloaded = true

            if ok && hasDirective(f.Directives, Directive.Test) {
                self.checkTestFn(ins)
            }
        }
    }

    // Prechecks types of current package file's functions.
    fn precheckFnTypes(mut &self) {
        for (_, mut decl) in self.file.Traits {
            for (_, mut m) in decl.Methods {
                self.precheckTypeFn(m)
            }
        }
        for (_, mut decl) in self.file.Funcs {
            self.precheckTypeFn(decl)
        }
    }

    // Checks types of current package file's functions.
    fn checkFnTypes(mut &self) {
        for (_, mut decl) in self.file.Funcs {
            self.checkTypeFn(decl)
        }
    }

    // Checks all types of all package files.
    // Breaks checking if checked file failed.
    fn checkPackageTypes(mut &self) {
        for (_, mut f) in self.files {
            self.setCurrentFile(f)
            self.checkGlobalTypes()
            self.precheckFnTypes()
            // Check structures first, see developer reference (7).
            // Check operators first, see developer reference (7.1), and (7.2).
            self.precheckStructTypes()
        }
        if len(self.errors) > 0 {
            ret
        }
        for (_, mut f) in self.files {
            self.setCurrentFile(f)
            self.checkFnTypes()
            self.checkStructTypes()
        }
    }

    fn setFileSemaFields(mut &self) {
        for (_, mut f) in self.file.Funcs {
            f.sema = self
        }
        for (_, mut st) in self.file.Structs {
            st.sema = self
        }
    }

    fn setSemaFields(mut &self) {
        for (_, mut file) in self.files {
            self.setCurrentFile(file)
            self.setFileSemaFields()
        }
    }

    fn check(mut &self, mut &files: []&SymbolTable) {
        self.files = files

        self.checkImports()
        if len(self.errors) != 0 {
            ret
        }

        self.setSemaFields()

        // Check enums here.
        // See developer reference (8).
        self.checkEnums()
        if len(self.errors) != 0 {
            ret
        }

        self.checkInherits()
        if len(self.errors) != 0 {
            ret
        }

        self.implImpls()
        if len(self.errors) != 0 {
            ret
        }

        self.checkPackageDecls()
        if len(self.errors) != 0 {
            ret
        }

        self.checkPackageTypes()
    }
}

struct missingRetChecker {
    mut breaked: []uintptr
    mut falled:  bool
}

impl missingRetChecker {
    static fn new(): missingRetChecker {
        ret missingRetChecker{
            breaked: make([]uintptr, 1 << 4),
        }
    }

    fn checkConditional(self, mut c: &Conditional): bool {
        for (_, mut elif) in c.Elifs {
            if elif == nil {
                ret false
            }
            if !self.checkScope(elif.Scope) {
                ret false
            }
        }
        ret c.Default != nil && self.checkScope(c.Default.Scope)
    }

    fn checkMatch(self, mut m: &Match): bool {
        for (_, mut c) in m.Cases {
            if c == nil {
                ret false
            }
            let n = len(self.breaked)
            let ok = self.checkScope(c.Scope)
            match {
            | n != len(self.breaked):
                ret false
            | !ok:
                if !self.falled {
                    ret false
                }
                fall
            | self.falled:
                self.falled = false
                if c.Next == nil {
                    ret false
                }
                continue
            }
        }
        ret m.Default != nil && self.checkScope(m.Default.Scope)
    }

    fn checkInfIter(self, mut it: &InfIter): bool {
        let n = len(self.breaked)
        if self.checkScope(it.Scope) {
            self.breaked = self.breaked[:n]
            ret true
        }
        if n != len(self.breaked) {
            let itaddr = uintptr(it)
            for _, addr in self.breaked[n:] {
                if itaddr == addr {
                    self.breaked = self.breaked[:n]
                    ret false
                }
            }
            self.breaked = self.breaked[:n]
        }
        ret true
    }

    fn checkScope(self, mut s: &Scope): bool {
        if s == nil {
            ret false
        }
        for (_, mut st) in s.Stmts {
            match type st {
            | &FallSt:
                self.falled = true
                ret false
            | &BreakSt:
                let addr = (&BreakSt)(st).It
                if addr != 0 {
                    self.breaked = append(self.breaked, addr)
                }
                ret false
            | &ContSt:
                ret false
            | &InfIter:
                if self.checkInfIter((&InfIter)(st)) {
                    ret true
                }
            | &RetSt:
                ret true
            | &Scope:
                if self.checkScope((&Scope)(st)) {
                    ret true
                }
            | &Data:
                match type (&Data)(st).Model {
                | &BuiltinPanicCallExprModel
                | &BuiltinErrorCallExprModel:
                    ret true
                }
            | &Conditional:
                if self.checkConditional((&Conditional)(st)) {
                    ret true
                }
            | &Match:
                if self.checkMatch((&Match)(st)) {
                    ret true
                }
            }
        }
        ret false
    }

    fn check(self, mut s: &Scope): bool {
        ret self.checkScope(s)
    }
}

fn pushImplemented(mut t: &Trait, mut &d: &Struct) {
push:
    match {
    | len(t.Implemented) > 0:
        for _, s in t.Implemented {
            if s == d {
                break push
            }
        }
        fall
    |:
        t.Implemented = append(t.Implemented, d)
    }
    for (_, mut i) in t.Inherits {
        pushImplemented(i.Kind.Trait(), d)
    }
}

fn pushImplements(mut &s: &Struct, mut t: &Trait) {
push:
    match {
    | len(s.Implements) > 0:
        for _, b in s.Implements {
            if b == t {
                break push
            }
        }
        fall
    |:
        s.Implements = append(s.Implements, t)
    }
    for (_, mut i) in t.Inherits {
        pushImplements(s, i.Kind.Trait())
    }
}