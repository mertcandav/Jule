// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::fs::path::{Join}
use std::jule::ast::{
    Ast,
    Constraint,
    Directive,
    Expr,
    ScopeTree,
    TypeDecl,
    TypeAliasDecl,
    VarDecl,
    GenericDecl,
    ParamDecl,
    IdentTypeDecl,
    RetTypeDecl,
    TupleTypeDecl,
    FnDecl,
    UseDecl,
    EnumItemDecl,
    EnumDecl,
    TypeEnumDecl,
    TypeEnumItemDecl,
    FieldDecl,
    StructDecl,
    TraitDecl,
    NodeData,
    Impl,
    Node,
}
use std::jule::lex::{
    File,
    Token,
    TokenId,
    TokenKind,
    Ident,
    IsIgnoreIdent,
}
use std::jule::build::{
    LogMsg,
    Log,
    LogKind,
    Logf,
    IsTopDirective,
}
use strings for std::strings
use utf8 for std::unicode::utf8
use unicode for std::unicode

fn makeErr(row: int, col: int, &f: &File, fmt: LogMsg, args: ...any): Log {
    ret Log{
        Kind: LogKind.Error,
        Row: row,
        Column: col,
        Path: f.Path,
        Text: Logf(fmt, args...),
    }
}

// Returns between of open and close ranges.
// Starts selection at i.
// Increases i for each selected token.
// i points to close range token after selection.
//
// Special cases are:
//  range(i, open, close, tokens) = nil if i > len(tokens)
//  range(i, open, close, tokens) = nil if tokens[i].Id != TokenId.Range
//  range(i, open, close, tokens) = nil if tokens[i].Kind != open
fn range(mut &i: int, open: TokenKind, close: TokenKind, mut &tokens: []&Token): []&Token {
    if i >= len(tokens) {
        ret nil
    }
    let tok = tokens[i]
    if tok.Id != TokenId.Range || tok.Kind != open {
        ret nil
    }
    i++
    let mut rangeN = 1
    let start = i
    for rangeN != 0 && i < len(tokens); i++ {
        let token = tokens[i]
        if token.Id == TokenId.Range {
            match token.Kind {
            | open:
                rangeN++
            | close:
                rangeN--
            }
        }
    }
    ret tokens[start:i-1]
}

// rangeLast returns last range from tokens.
// Returns tokens without range tokens and range tokens.
// Range tokens includes left and right range tokens.
//
// Special cases are;
//  rangeLast(tokens) = tokens, nil if len(tokens) == 0
//  rangeLast(tokens) = tokens, nil if tokens is not has range at last
fn rangeLast(mut &tokens: []&Token): (cutted: []&Token, cut: []&Token) {
    if len(tokens) == 0 {
        ret tokens, nil
    } else if tokens[len(tokens)-1].Id != TokenId.Range {
        ret tokens, nil
    }
    let mut braceN = 0
    let mut i = len(tokens) - 1
    for i >= 0; i-- {
        let token = tokens[i]
        if token.Id == TokenId.Range {
            match token.Kind {
            | TokenKind.RBrace
            | TokenKind.RBracket
            | TokenKind.RParent:
                braceN++
                continue
            |:
                braceN--
            }
        }
        if braceN == 0 {
            ret tokens[:i], tokens[i:]
        }
    }
    ret tokens, nil
}

// Same as parts, but uses TokenKind as separator.
fn partsKind(mut &tokens: []&Token, kind: TokenKind, expr_must: bool): ([][]&Token, []Log) {
    if len(tokens) == 0 {
        ret nil, nil
    }

    let mut parts: [][]&Token = nil
    let mut errors: []Log = nil

    let mut rangeN = 0
    let mut last = 0
    for i, token in tokens {
        if token.Id == TokenId.Range {
            match token.Kind {
            | TokenKind.LBrace
            | TokenKind.LBracket
            | TokenKind.LParent:
                rangeN++
                continue
            |:
                rangeN--
            }
        }

        if rangeN > 0 {
            continue
        }

        if token.Kind == kind {
            if expr_must && i-last <= 0 {
                let err = makeErr(token.Row, token.Column, token.File, LogMsg.MissingExpr)
                errors = append(errors, err)
            }
            parts = append(parts, tokens[last:i])
            last = i + 1
        }
    }

    if last < len(tokens) {
        parts = append(parts, tokens[last:])
    } else if !expr_must {
        parts = append(parts, [])
    }

    ret parts, errors
}

// Returns parts separated by given token identifier.
// It's skips parentheses ranges.
// Logs missing_expr if expr_must == true and not exist any expression for part.
//
// Special case is;
//  parts(tokens) = nil if len(tokens) == 0
fn parts(mut &tokens: []&Token, id: TokenId, expr_must: bool): ([][]&Token, []Log) {
    if len(tokens) == 0 {
        ret nil, nil
    }

    let mut parts: [][]&Token = nil
    let mut errors: []Log = nil

    let mut rangeN = 0
    let mut last = 0
    for i, token in tokens {
        if token.Id == TokenId.Range {
            match token.Kind {
            | TokenKind.LBrace
            | TokenKind.LBracket
            | TokenKind.LParent:
                rangeN++
                continue
            |:
                rangeN--
            }
        }

        if rangeN > 0 {
            continue
        }

        if token.Id == id {
            if expr_must && i-last <= 0 {
                let err = makeErr(token.Row, token.Column, token.File, LogMsg.MissingExpr)
                errors = append(errors, err)
            }
            parts = append(parts, tokens[last:i])
            last = i + 1
        }
    }

    if last < len(tokens) {
        parts = append(parts, tokens[last:])
    } else if !expr_must {
        parts = append(parts, [])
    }

    ret parts, errors
}

fn getCloseKindOfBrace(left: str): str {
    match left {
    | TokenKind.RParent:
        ret TokenKind.LParent
    | TokenKind.RBrace:
        ret TokenKind.LBrace
    | TokenKind.RBracket:
        ret TokenKind.LBracket
    |:
        ret ""
    }
}

fn compilerErr(&token: &Token, &fmt: LogMsg, args: ...any): Log {
    ret Log{
        Kind: LogKind.Error,
        Row: token.Row,
        Column: token.Column,
        Path: token.File.Path,
        Text: Logf(fmt, args...),
        Line: token.File.GetRow(token.Row),
    }
}

unsafe fn pushSuggestion(mut log: *Log, fmt: LogMsg, args: ...any) {
    log.Suggestion = Logf(fmt, args...)
}

fn tokstoa(&tokens: []&Token): str {
    let mut n = 0
    for _, token in tokens {
        n += len(token.Kind)
    }
    let mut s = make(str, 0, n)
    for _, token in tokens {
        s += token.Kind
    }
    ret s
}

struct parser {
    ast:        &Ast
    directives: []&Directive
    errors:     []Log
}

impl parser {
    fn stop(mut self) { self.ast = nil }
    fn stopped(self): bool { ret self.ast == nil }

    // Appends error by specified token, key and args.
    fn pushErr(mut self, token: &Token, fmt: LogMsg, args: ...any) {
        self.errors = append(self.errors, compilerErr(token, fmt, args...))
    }

    // Push suggestion to last log.
    fn pushSuggestion(mut self, fmt: LogMsg, args: ...any) {
        unsafe { pushSuggestion(&self.errors[len(self.errors)-1], fmt, args...) }
    }

    fn buildExpr(mut &self, mut &tokens: []&Token): &Expr {
        let mut ep = &exprBuilder{
            p: self,
        }
        let mut expr = ep.buildFromTokens(tokens)
        ret expr
    }

    fn buildDirective(mut self, mut tokens: []&Token): &Directive {
        if len(tokens) == 1 {
            self.pushErr(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }
        if tokens[1].Column != tokens[0].Column+1 {
            self.pushErr(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }
        ret &Directive{
            Tag: tokens[1],
            Args: tokens[2:],// Start 2 to skip '#', and tag tokens. 
        }
    }

    fn pushDirective(mut self, mut d: &Directive) {
        if d == nil {
            ret
        }
        // Don't append if already added this directive.
        for _, pd in self.directives {
            if d.Tag.Kind == pd.Tag.Kind {
                ret
            }
        }
        self.directives = append(self.directives, d)
    }

    fn buildScope(mut &self, mut &tokens: []&Token, mut end: &Token): &ScopeTree {
        let mut s = newScope()
        s.End = end
        let mut sp = scopeParser{
            p: self,
        }
        sp.build(tokens, s)
        ret s
    }

    unsafe fn _buildType(mut &self, mut &tokens: []&Token,
        mut i: *int, err: bool): (&TypeDecl, bool) {
        let mut tb = typeBuilder{
            p: self,
            tokens: tokens,
            i: i,
            err: err,
        }
        let (mut decl, ok) = tb.build()
        ret decl, ok
    }

    // Builds AST model of data-type.
    unsafe fn buildType(mut &self, mut &tokens: []&Token,
        mut i: *int, err: bool): (&TypeDecl, bool) {
        let token = tokens[*i]
        let (mut t, ok) = self._buildType(tokens, i, err)
        if err && !ok {
            self.pushErr(token, LogMsg.InvalidType)
        }
        ret t, ok
    }

    fn buildTypeAliasDecl(mut &self, mut &tokens: []&Token): &TypeAliasDecl {
        let mut i = 1 // Skip "type" keyword.
        if i >= len(tokens) {
            self.pushErr(tokens[i-1], LogMsg.InvalidSyntax)
            ret nil
        }
        let mut tad = &TypeAliasDecl{
            Token: tokens[1],
            Ident: tokens[1].Kind,
        }
        let mut token = tokens[i]
        if token.Id != TokenId.Ident {
            self.pushErr(token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
        }
        i++
        if i >= len(tokens) {
            self.pushErr(tokens[i-1], LogMsg.InvalidSyntax)
            ret tad
        }
        token = tokens[i]
        if token.Id != TokenId.Colon {
            self.pushErr(tokens[i-1], LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedColon)
            ret tad
        }
        i++
        if i >= len(tokens) {
            self.pushErr(tokens[i-1], LogMsg.MissingType)
            ret tad
        }
        let (mut t, ok) = unsafe { self.buildType(tokens, &i, true) }
        tad.Kind = t
        if ok && i < len(tokens) {
            self.pushErr(tokens[i], LogMsg.InvalidSyntax)
        }
        tad.Public = isPub(tad.Ident)
        ret tad
    }

    fn buildVarTypeAndExpr(mut &self, mut &v: &VarDecl, mut &tokens: []&Token) {
        let mut i = 0
        let mut tok = tokens[i]
        if tok.Id == TokenId.Colon {
            i++ // Skip type annotation operator (:)
            if (i >= len(tokens) ||
                (tokens[i].Id == TokenId.Op && tokens[i].Kind == TokenKind.Eq)) {
                self.pushErr(tok, LogMsg.MissingType)
                ret
            }
            let (mut t, ok) = unsafe { self.buildType(tokens, &i, true) }
            if ok {
                v.Kind = t
                if i >= len(tokens) {
                    ret
                }
                tok = tokens[i]
            }
        }

        if tok.Id == TokenId.Op {
            if tok.Kind != TokenKind.Eq {
                self.pushErr(tok, LogMsg.InvalidSyntax)
                ret
            }
            let mut exprTokens = tokens[i+1:]
            if len(exprTokens) == 0 {
                self.pushErr(tok, LogMsg.MissingExpr)
                ret
            }
            v.Expr = self.buildExpr(exprTokens)
        } else {
            self.pushErr(tok, LogMsg.InvalidSyntax)
        }
    }

    fn buildVarCommon(mut &self, mut &v: &VarDecl, mut tokens: []&Token) {
        v.Token = tokens[0]
        if v.Token.Id != TokenId.Ident {
            self.pushErr(v.Token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
            ret
        }
        v.Ident = v.Token.Kind
        v.Public = isPub(v.Ident)
        v.Kind = nil // For auto-type.
        if len(tokens) > 1 {
            tokens = tokens[1:] // Remove identifier.
            self.buildVarTypeAndExpr(v, tokens)
        }
    }

    fn buildVarBegin(mut self, mut &v: &VarDecl, mut &i: int, &tokens: []&Token) {
        let tok = tokens[i]
        match tok.Id {
        | TokenId.Static:
            v.Statically = true
            fall
        | TokenId.Let:
            // Initialize 1 for skip the let keyword
            i++
            if i >= len(tokens) {
                self.pushErr(tok, LogMsg.InvalidSyntax)
                ret
            }
            if tokens[i].Id == TokenId.Mut {
                v.Mutable = true
                // Skip the mut keyword
                i++
            }
        | TokenId.Const:
            i++
            v.Constant = true
        |:
            self.pushErr(tok, LogMsg.InvalidSyntax)
            ret
        }
        if i >= len(tokens) {
            self.pushErr(tok, LogMsg.InvalidSyntax)
        }
    }

    fn buildVar(mut &self, mut tokens: []&Token): &VarDecl {
        let mut i = 0
        let mut v = &VarDecl{
            Token: tokens[0],
        }
        self.buildVarBegin(v, i, tokens)
        if i >= len(tokens) {
            ret nil
        }

        tokens = tokens[i:]
        if tokens[0].Id == TokenId.Op && tokens[0].Kind == TokenKind.Amper {
            v.Reference = true
            if len(tokens) == 1 {
                ret nil
            }
            tokens = tokens[1:]
        }
        self.buildVarCommon(v, tokens)
        ret v
    }

    fn buildGeneric(mut &self, mut &tokens: []&Token): &GenericDecl {
        let mut g = &GenericDecl{
            Token: tokens[0],
        }
        if g.Token.Id != TokenId.Ident {
            self.pushErr(g.Token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
        }
        g.Ident = g.Token.Kind
        if len(tokens) > 1 {
            if tokens[1].Id != TokenId.Colon {
                self.pushErr(tokens[1], LogMsg.InvalidSyntax)
                ret nil
            }
            if len(tokens) == 2 {
                self.pushErr(tokens[1], LogMsg.MissingExpr)
                ret nil
            }
            let mut constraintTokens = tokens[2:]
            let (mut parts, errors) = partsKind(constraintTokens, TokenKind.Vline, true)
            if len(errors) > 0 {
                self.errors = append(self.errors, errors...)
                ret nil
            }
            g.Constraint = &Constraint{Mask: make([]&TypeDecl, 0, len(parts))}
            for (_, mut part) in parts {
                let mut i = 0
                let (mut kind, _) = unsafe { self.buildType(part, &i, true) }
                g.Constraint.Mask = append(g.Constraint.Mask, kind)
                if i < len(part) {
                    self.pushErr(part[i], LogMsg.InvalidSyntax)
                }
            }
        }
        ret g
    }

    fn buildGenerics(mut &self, mut &tokens: []&Token, &errorToken: &Token): []&GenericDecl {
        if len(tokens) == 0 {
            self.pushErr(errorToken, LogMsg.MissingExpr)
            ret nil
        }

        let (mut parts, errors) = parts(tokens, TokenId.Comma, true)
        if len(errors) > 0 {
            self.errors = append(self.errors, errors...)
            ret nil
        }

        let mut generics = make([]&GenericDecl, 0, len(parts))
        for (_, mut part) in parts {
            generics = append(generics, self.buildGeneric(part))
        }

        ret generics
    }

    fn buildSelfParam(mut self, mut tokens: []&Token): &ParamDecl {
        if len(tokens) == 0 {
            ret nil
        }

        let mut param = new(ParamDecl)

        // Detects mut keyword.
        let mut i = 0
        if tokens[i].Id == TokenId.Mut {
            param.Mutable = true
            i++
            if i >= len(tokens) {
                self.pushErr(tokens[i-1], LogMsg.InvalidSyntax)
                ret nil
            }
        }

        if tokens[i].Kind == TokenKind.Amper {
            param.Ident = TokenKind.Amper
            i++
            if i >= len(tokens) {
                self.pushErr(tokens[i-1], LogMsg.InvalidSyntax)
                ret nil
            }
        }

        if tokens[i].Id == TokenId.Self {
            param.Ident += str(TokenKind.Self)
            param.Token = tokens[i]
            i++
            if i < len(tokens) {
                self.pushErr(tokens[i], LogMsg.InvalidSyntax)
            }
        }

        ret param
    }

    fn paramTypeBegin(mut self, mut &param: &ParamDecl, mut &i: int, &tokens: []&Token) {
        for i < len(tokens); i++ {
            let token = tokens[i]
            if token.Id != TokenId.Op {
                ret
            } else if token.Kind != TokenKind.TripleDot {
                ret
            }

            if param.Variadic {
                self.pushErr(token, LogMsg.AlreadyVariadic)
                continue
            }
            param.Variadic = true
        }
    }

    fn buildParamType(mut &self, mut &param: &ParamDecl, mut &tokens: []&Token) {
        let mut i = 0
        self.paramTypeBegin(param, i, tokens)
        if i >= len(tokens) {
            ret
        }

        param.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
        if i < len(tokens) {
            self.pushErr(tokens[i], LogMsg.InvalidSyntax)
        }
    }

    fn buildParamBody(mut &self, mut &param: &ParamDecl, mut tokens: []&Token) {
        let mut tok = tokens[0]
        if len(tokens) == 1 {
            // Just identifier token.
            param.Ident = tok.Kind
            ret
        } else if len(tokens) < 3 {
            self.pushErr(tok, LogMsg.MissingType)
            ret
        }
        if tokens[1].Id != TokenId.Colon {
            param.Ident = Ident.Anon
            self.buildParamType(param, tokens)
            ret
        }
        param.Ident = tok.Kind
        tokens = tokens[2:] // Skip colon
        self.buildParamType(param, tokens)
    }

    fn buildParam(mut &self, mut tokens: []&Token): &ParamDecl {
        let mut param = &ParamDecl{
            Token: tokens[0],
        }

        // Detects mut keyword.
        if param.Token.Id == TokenId.Mut {
            param.Mutable = true
            if len(tokens) == 1 {
                self.pushErr(tokens[0], LogMsg.InvalidSyntax)
                ret nil
            }
            tokens = tokens[1:]
            param.Token = tokens[0]
        }

        // Catch reference parameters.
        if len(tokens) >= 3 {
            if param.Token.Id == TokenId.Op && param.Token.Kind == TokenKind.Amper {
                if len(tokens) == 1 {
                    self.pushErr(tokens[0], LogMsg.InvalidSyntax)
                    ret nil
                }

                if tokens[1].Id == TokenId.Ident && tokens[2].Id == TokenId.Colon {
                    param.Reference = true
                    tokens = tokens[1:]
                    param.Token = tokens[0]
                }
            }
        }

        if param.Token.Id != TokenId.Ident {
            // Just data type
            param.Ident = Ident.Anon
            self.buildParamType(param, tokens)
        } else {
            self.buildParamBody(param, tokens)
        }

        ret param
    }

    fn checkParams(mut self, mut &params: []&ParamDecl) {
        for (_, mut param) in params {
            if param.IsSelf() || param.Kind != nil {
                continue
            }
            if param.Token == nil {
                self.pushErr(param.Token, LogMsg.MissingType)
            } else {
                param.Kind = &TypeDecl{
                    Token: param.Token,
                    Kind: &IdentTypeDecl{
                        Token: param.Token,
                        Ident: param.Token.Kind,
                    },
                }
                param.Ident = Ident.Anon
            }
        }
    }

    fn buildParams(mut &self, mut &tokens: []&Token, method: bool): []&ParamDecl {
        let (mut parts, errs) = parts(tokens, TokenId.Comma, true)
        self.errors = append(self.errors, errs...)
        if len(parts) == 0 {
            ret nil
        }

        let mut params: []&ParamDecl = nil
        if method && len(parts) > 0 {
            let mut param = self.buildSelfParam(parts[0])
            if param != nil && param.IsSelf() {
                params = append(params, param)
                parts = parts[1:]
            }
        }

        for (_, mut part) in parts {
            let mut param = self.buildParam(part)
            if param != nil {
                params = append(params, param)
            }
        }

        self.checkParams(params)
        ret params
    }

    fn buildMultiRetType(mut &self, mut &tokens: []&Token, mut &i: int): (t: &RetTypeDecl, ok: bool) {
        t = new(RetTypeDecl)
        i++
        if i >= len(tokens) {
            i--
            t.Kind, ok = unsafe { self.buildType(tokens, &i, false) }
            ret
        }

        i-- // For point to parentheses - ( -
        let mut rangeTokens = range(i, TokenKind.LParent, TokenKind.RParent, tokens)

        let (mut parts, errs) = parts(rangeTokens, TokenId.Comma, true)
        self.errors = append(self.errors, errs...)
        if len(parts) == 0 {
            ret
        }

        let mut types = make([]&TypeDecl, 0, len(parts))
        t.Idents = make([]&Token, 0, len(parts))
        for (_, mut part) in parts {
            let mut token = part[0]
            let mut offset = 0

            // Check type annotation.
            if len(part) > 1 {
                token = part[1]
                if token.Id == TokenId.Colon {
                    offset = 2
                    if len(part) < 3 {
                        self.pushErr(token, LogMsg.MissingType)
                        continue
                    }
                }
            }

            token = part[0]
            if offset != 2 {
                let mut newToken = new(Token, *token)
                newToken.Kind = Ident.Anon
                t.Idents = append(t.Idents, newToken)
            } else {
                t.Idents = append(t.Idents, token)
            }

            let (mut tk, _) = unsafe { self.buildType(part, &offset, true) }
            if offset < len(part) {
                self.pushErr(part[offset], LogMsg.InvalidSyntax)
            }
            types = append(types, tk)
        }

        if len(types) > 1 {
            t.Kind = &TypeDecl{
                Token: tokens[0],
                Kind: &TupleTypeDecl{
                    Types: types,
                },
            }
        } else {
            t.Kind = types[0]
        }

        ok = true
        ret
    }

    // Builds function return type from tokens.
    fn buildRetType(mut &self, mut &tokens: []&Token, mut &i: int): (t: &RetTypeDecl, ok: bool) {
        t = new(RetTypeDecl)
        if i >= len(tokens) {
            ret
        }

        let mut token = tokens[i]
        match token.Id {
        | TokenId.Range:
            if token.Kind == TokenKind.LBrace {
                ret
            }
        | TokenId.Op:
            if token.Kind == TokenKind.Eq {
                ret
            }
        | TokenId.Colon:
            if i+1 >= len(tokens) {
                self.pushErr(token, LogMsg.MissingType)
                ret
            }

            i++
            token = tokens[i]
            if token.Id == TokenId.Range {
                match token.Kind {
                | TokenKind.LParent:
                    t, ok = self.buildMultiRetType(tokens, i)
                    ret
                | TokenKind.LBrace:
                    self.pushErr(token, LogMsg.MissingType)
                    ret
                }
            }
            t.Kind, ok = unsafe { self.buildType(tokens, &i, true) }
            ret
        }
        i++
        self.pushErr(token, LogMsg.InvalidSyntax)
        ret
    }

    // Build function prototype.
    // Body is not necessary for successfull parsing.
    // Just declration.
    fn buildFnPrototype(mut &self, mut &tokens: []&Token, mut &i: int, method: bool): &FnDecl {
        let mut f = &FnDecl{
            Token: tokens[i],
        }

        // Detect static keyword.
        if f.Token.Id == TokenId.Static {
            f.Statically = true
            i++
            if i >= len(tokens) {
                self.pushErr(f.Token, LogMsg.InvalidSyntax)
                ret nil
            }
            f.Token = tokens[i]
        }

        // Detect unsafe keyword.
        if f.Token.Id == TokenId.Unsafe {
            f.Unsafety = true
            i++
            if i >= len(tokens) {
                self.pushErr(f.Token, LogMsg.InvalidSyntax)
                ret nil
            }
            f.Token = tokens[i]
        }

        // Skips fn token.
        i++
        if i >= len(tokens) {
            self.pushErr(f.Token, LogMsg.InvalidSyntax)
            ret nil
        }

        let tok = tokens[i]
        if tok.Id == TokenId.Ident {
            i++
            if i >= len(tokens) {
                self.pushErr(f.Token, LogMsg.InvalidSyntax)
                ret nil
            }
            f.Ident = tok.Kind
        } else {
            f.Ident = Ident.Anon
        }

        let errorToken = tokens[i]
        let mut genericsTokens = range(i, TokenKind.LBracket, TokenKind.RBracket, tokens)
        if genericsTokens != nil {
            f.Generics = self.buildGenerics(genericsTokens, errorToken)
        }

        if tokens[i].Kind != TokenKind.LParent {
            self.pushErr(tokens[i], LogMsg.MissingFnParentheses)
            ret nil
        }

        let mut paramsToks = range(i, TokenKind.LParent, TokenKind.RParent, tokens)
        if len(paramsToks) > 0 {
            f.Params = self.buildParams(paramsToks, method)
        }

        if i < len(tokens) {
            let token = tokens[i]
            if token.Id == TokenId.Op && token.Kind == TokenKind.Excl {
                f.Exceptional = true
                i++
            }
        }

        f.Public = isPub(f.Ident)
        f.Result, _ = self.buildRetType(tokens, i)
        ret f
    }

    // Parses function define.
    // Prototype and body.
    fn buildFn(mut &self, mut &tokens: []&Token, method: bool, prototype: bool): &FnDecl {
        let mut i = 0
        let mut f = self.buildFnPrototype(tokens, i, method)
        if prototype {
            if i < len(tokens) {
                self.pushErr(tokens[i+1], LogMsg.InvalidSyntax)
            }
            ret f
        } else if f == nil {
            ret f
        }

        if i >= len(tokens) {
            self.stop()
            self.pushErr(f.Token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret nil
        }
        let mut blockTokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if blockTokens != nil {
            f.Scope = self.buildScope(blockTokens, tokens[i-1])
            f.Scope.Unsafety = f.Unsafety
            if i < len(tokens) {
                self.pushErr(tokens[i], LogMsg.InvalidSyntax)
            }
        } else {
            self.stop()
            self.pushErr(f.Token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret nil
        }
        ret f
    }

    fn getUseDeclSelectors(mut self, mut tokens: []&Token): []&Token {
        let mut i = 0
        tokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        let (mut parts, errs) = parts(tokens, TokenId.Comma, true)
        if len(errs) > 0 {
            self.errors = append(self.errors, errs...)
            ret nil
        }

        let mut selectors = make([]&Token, 0, len(parts))
        for (_, mut part) in parts {
            if len(part) > 1 {
                self.pushErr(part[1], LogMsg.InvalidSyntax)
            }
            let mut tok = part[0]
            if tok.Id != TokenId.Ident && tok.Id != TokenId.Self {
                self.pushErr(tok, LogMsg.InvalidSyntax)
                self.pushSuggestion(LogMsg.ExpectedIdentifier)
                continue
            }
            selectors = append(selectors, tok)
        }
        ret selectors
    }

    fn buildCppUseDecl(mut self, mut &decl: &UseDecl, &tokens: []&Token) {
        if len(tokens) > 1 {
            self.pushErr(tokens[1], LogMsg.InvalidSyntax)
        }
        let token = tokens[0]
        if token.Id != TokenId.Lit || (token.Kind[0] != '`' && token.Kind[0] != '"') {
            self.pushErr(token, LogMsg.InvalidExpr)
            ret
        }
        decl.CppLinked = true
        decl.LinkPath = token.Kind[1:len(token.Kind)-1]
    }

    fn buildStdUseDecl(mut self, mut &decl: &UseDecl, mut tokens: []&Token) {
        decl.Std = true

        let mut token = tokens[0]
        if len(tokens) < 3 {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret
        }

        tokens = tokens[2:]
        token = tokens[len(tokens)-1]
        match token.Id {
        | TokenId.DblColon:
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret
        | TokenId.Range:
            if token.Kind != TokenKind.RBrace {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
            let mut selectors: []&Token = nil
            tokens, selectors = rangeLast(tokens)
            decl.Selected = self.getUseDeclSelectors(selectors)
            if len(tokens) == 0 {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
            token = tokens[len(tokens)-1]
            if token.Id != TokenId.DblColon {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
            tokens = tokens[:len(tokens)-1]
            if len(tokens) == 0 {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
        | TokenId.Op:
            if token.Kind != TokenKind.Star {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
            tokens = tokens[:len(tokens)-1]
            if len(tokens) == 0 {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
            token = tokens[len(tokens)-1]
            if token.Id != TokenId.DblColon {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
            tokens = tokens[:len(tokens)-1]
            if len(tokens) == 0 {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
            decl.Full = true
        }
        decl.LinkPath = "std::" + tokstoa(tokens)
    }

    fn buildIdentUseDecl(mut self, mut &decl: &UseDecl, mut tokens: []&Token) {
        decl.Std = false

        let mut token = tokens[len(tokens)-1]
        match token.Id {
        | TokenId.DblColon:
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret
        | TokenId.Range:
            if token.Kind != TokenKind.RBrace {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }

            let mut selectors: []&Token = nil
            tokens, selectors = rangeLast(tokens)
            decl.Selected = self.getUseDeclSelectors(selectors)
            if len(tokens) == 0 {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }

            token = tokens[len(tokens)-1]
            if token.Id != TokenId.DblColon {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }

            tokens = tokens[:len(tokens)-1]
            if len(tokens) == 0 {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }
        | TokenId.Op:
            if token.Kind != TokenKind.Star {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }

            tokens = tokens[:len(tokens)-1]
            if len(tokens) == 0 {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }

            token = tokens[len(tokens)-1]
            if token.Id != TokenId.DblColon {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }

            tokens = tokens[:len(tokens)-1]
            if len(tokens) == 0 {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret
            }

            decl.Full = true
        }

        decl.LinkPath = tokstoa(tokens)
    }

    fn parseUseDecl(mut self, mut &decl: &UseDecl, mut tokens: []&Token) {
        if decl.CppLinked {
            self.buildCppUseDecl(decl, tokens)
            ret
        }

        let mut token = tokens[0]
        if token.Id != TokenId.Ident {
            self.pushErr(token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
            ret
        }

        if len(tokens) > 2 && tokens[1].Id == TokenId.For {
            decl.Alias = token.Kind
            if tokens[2].Id != TokenId.Ident {
                self.pushErr(token, LogMsg.InvalidSyntax)
                self.pushSuggestion(LogMsg.ExpectedIdentifier)
                ret
            }
            tokens = tokens[2:]
            token = tokens[0]
        }

        const StdlibPrefix = "std"

        match {
        | token.Kind == StdlibPrefix:
            self.buildStdUseDecl(decl, tokens)
        |:
            self.buildIdentUseDecl(decl, tokens)
        }
    }

    fn buildUseDecl(mut self, mut tokens: []&Token, cpp_linked: bool): &UseDecl {
        let mut decl = &UseDecl{
            Token: tokens[0],
            CppLinked: cpp_linked,
        }
        if len(tokens) < 2 {
            self.pushErr(decl.Token, LogMsg.MissingUsePath)
            ret nil
        }
        tokens = tokens[1:] // Skip "use" keyword.
        self.parseUseDecl(decl, tokens)
        ret decl
    }

    fn buildTypeEnumItemKind(mut &self, mut &i: int, mut &tokens: []&Token): &TypeDecl {
        let mut braceN = 0
        let exprStart = i
        for i < len(tokens); i++ {
            let t = tokens[i]
            if t.Id == TokenId.Range {
                match t.Kind {
                | TokenKind.LBrace
                | TokenKind.LBracket
                | TokenKind.LParent:
                    braceN++
                    continue
                |:
                    braceN--
                }
            }
            if braceN > 0 {
                continue
            }
            if t.Id == TokenId.Comma || i+1 >= len(tokens) {
                let mut kindTokens: []&Token = nil
                if t.Id == TokenId.Comma {
                    kindTokens = tokens[exprStart:i]
                } else {
                    kindTokens = tokens[exprStart:]
                }
                let mut j = 0
                let (mut kind, _) = unsafe { self.buildType(kindTokens, &j, true) }
                if j < len(kindTokens) {
                    self.pushErr(kindTokens[j], LogMsg.InvalidSyntax)
                }
                ret kind
            }
        }
        ret nil
    }

    fn buildTypeEnumItems(mut &self, mut &tokens: []&Token): []&TypeEnumItemDecl {
        let mut items = make([]&TypeEnumItemDecl, 0, 1)
        let mut i = 0
        for i < len(tokens); i++ {
            let mut t = tokens[i]
            let mut item = new(TypeEnumItemDecl)
            item.Token = t
            if item.Token.Id == TokenId.Ident && len(tokens)-i > 2 {
                item.Ident = item.Token.Kind
                t = tokens[i+1]
                if t.Id == TokenId.Colon {
                    i += 2
                    if i >= len(tokens) || tokens[i].Id == TokenId.Comma {
                        self.pushErr(t, LogMsg.MissingType)
                        continue
                    }
                }
            }
            item.Kind = self.buildTypeEnumItemKind(i, tokens)
            items = append(items, item)
        }
        ret items
    }

    fn buildTypeEnumDecl(mut &self, mut &tokens: []&Token): &TypeEnumDecl {
        let mut i = 1
        let mut e = &TypeEnumDecl{
            // Skip "enum" tokens.
            Token: tokens[i],
        }
        if e.Token.Id != TokenId.Ident {
            self.pushErr(e.Token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
        }
        e.Ident = e.Token.Kind
        i += 3 // Skip "identifier: type" tokens.
        let mut itemTokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if itemTokens == nil {
            self.stop()
            self.pushErr(e.Token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret e
        } else if i < len(tokens) {
            self.pushErr(tokens[i], LogMsg.InvalidSyntax)
        }
        e.Public = isPub(e.Ident)
        e.End = tokens[i-1]
        e.Items = self.buildTypeEnumItems(itemTokens)
        ret e
    }

    fn buildEnumItemExpr(mut &self, mut &i: int, mut &tokens: []&Token): &Expr {
        let mut braceN = 0
        let exprStart = i
        for i < len(tokens); i++ {
            let t = tokens[i]
            if t.Id == TokenId.Range {
                match t.Kind {
                | TokenKind.LBrace
                | TokenKind.LBracket
                | TokenKind.LParent:
                    braceN++
                    continue
                |:
                    braceN--
                }
            }
            if braceN > 0 {
                continue
            }
            if t.Id == TokenId.Comma || i+1 >= len(tokens) {
                let mut exprTokens: []&Token = nil
                if t.Id == TokenId.Comma {
                    exprTokens = tokens[exprStart:i]
                } else {
                    exprTokens = tokens[exprStart:]
                }
                ret self.buildExpr(exprTokens)
            }
        }
        ret nil
    }

    fn buildEnumItems(mut &self, mut &tokens: []&Token): []&EnumItemDecl {
        let mut items = make([]&EnumItemDecl, 0, 1)
        let mut i = 0
        for i < len(tokens); i++ {
            let mut t = tokens[i]
            let mut item = new(EnumItemDecl)
            item.Token = t
            if item.Token.Id != TokenId.Ident {
                self.pushErr(item.Token, LogMsg.InvalidSyntax)
                self.pushSuggestion(LogMsg.ExpectedIdentifier)
            }
            item.Ident = item.Token.Kind
            if i+1 >= len(tokens) || tokens[i+1].Id == TokenId.Comma {
                if i+1 < len(tokens) {
                    i++
                }
                items = append(items, item)
                continue
            }
            i++
            t = tokens[i]
            i++
            if t.Id != TokenId.Colon {
                self.pushErr(t, LogMsg.InvalidSyntax)
                self.pushSuggestion(LogMsg.ExpectedColonForAssign)
                continue
            }
            if i >= len(tokens) || tokens[i].Id == TokenId.Comma {
                self.pushErr(t, LogMsg.MissingExpr)
                continue
            }
            item.Expr = self.buildEnumItemExpr(i, tokens)
            items = append(items, item)
        }
        ret items
    }

    fn buildEnumDecl(mut &self, mut &tokens: []&Token): &EnumDecl {
        if len(tokens) < 3 {
            self.pushErr(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }
        let mut e = &EnumDecl{
            Token: tokens[1],
        }
        if e.Token.Id != TokenId.Ident {
            self.pushErr(e.Token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
        }
        e.Ident = e.Token.Kind
        let mut i = 2
        if tokens[i].Id == TokenId.Colon {
            i++
            if i >= len(tokens) {
                self.pushErr(tokens[i-1], LogMsg.InvalidSyntax)
                ret e
            }
            e.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
            if i >= len(tokens) {
                self.stop()
                self.pushErr(e.Token, LogMsg.BodyNotExist)
                self.pushSuggestion(LogMsg.ExpectedBody)
                ret e
            }
        } else {
            e.Kind = nil
        }
        let mut itemTokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if itemTokens == nil {
            self.stop()
            self.pushErr(e.Token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret e
        } else if i < len(tokens) {
            self.pushErr(tokens[i], LogMsg.InvalidSyntax)
        }
        e.Public = isPub(e.Ident)
        e.End = tokens[i-1]
        e.Items = self.buildEnumItems(itemTokens)
        ret e
    }

    fn buildNodeEnumDecl(mut &self, mut &tokens: []&Token): NodeData {
        if len(tokens) > 3 && tokens[2].Id == TokenId.Colon {
            if tokens[3].Id == TokenId.Type {
                ret self.buildTypeEnumDecl(tokens)
            }
        }
        ret self.buildEnumDecl(tokens)
    }

    fn buildField(mut &self, mut tokens: []&Token): &FieldDecl {
        let mut f = new(FieldDecl)

        f.Mutable = tokens[0].Id == TokenId.Mut
        if f.Mutable {
            if len(tokens) == 1 {
                self.pushErr(tokens[0], LogMsg.InvalidSyntax)
                ret nil
            }
            tokens = tokens[1:]
        }

        f.Token = tokens[0]
        if f.Token.Id != TokenId.Ident {
            self.pushErr(f.Token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
            ret nil
        }
        f.Ident = f.Token.Kind

        if len(tokens) == 1 {
            self.pushErr(tokens[0], LogMsg.MissingType)
            ret nil
        } else if tokens[1].Id != TokenId.Colon {
            self.pushErr(tokens[1], LogMsg.MissingType)
            ret nil
        }

        tokens = tokens[2:] // Remove identifier and colon tokens.
        let mut i = 0
        f.Kind, _ = unsafe { self.buildType(tokens, &i, true) }
        if i < len(tokens) {
            let token = tokens[i]
            if token.Id != TokenId.Op || token.Kind != TokenKind.Eq {
                self.pushErr(tokens[i], LogMsg.InvalidSyntax)
                ret nil
            }
            i++
            if i >= len(tokens) {
                self.pushErr(token, LogMsg.MissingExpr)
                ret nil
            }
            tokens = tokens[i:]
            f.Default = self.buildExpr(tokens)
        }
        f.Public = isPub(f.Ident)
        ret f
    }

    fn buildStructDeclFields(mut &self, mut tokens: []&Token): []&FieldDecl {
        let mut fields: []&FieldDecl = nil
        let mut stmts = splitStmts(tokens)
        for (_, mut stmt) in stmts {
            tokens = stmt.tokens
            let mut f = self.buildField(tokens)
            fields = append(fields, f)
        }
        ret fields
    }

    fn buildStructDecl(mut &self, mut &tokens: []&Token): &StructDecl {
        if len(tokens) < 3 {
            self.pushErr(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }

        let mut i = 1
        let mut s = &StructDecl{
            Token: tokens[i],
        }
        if s.Token.Id != TokenId.Ident {
            self.pushErr(s.Token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
        }
        i++
        if i >= len(tokens) {
            self.pushErr(tokens[i], LogMsg.InvalidSyntax)
            ret s
        }
        s.Ident = s.Token.Kind

        let errorToken = tokens[i]
        let mut genericsTokens = range(i, TokenKind.LBracket, TokenKind.RBracket, tokens)
        if genericsTokens != nil {
            s.Generics = self.buildGenerics(genericsTokens, errorToken)
        }
        if i >= len(tokens) {
            self.pushErr(tokens[i-1], LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret s
        }

        let mut bodyTokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if bodyTokens == nil {
            self.stop()
            self.pushErr(s.Token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret s
        }
        if i < len(tokens) {
            self.pushErr(tokens[i], LogMsg.InvalidSyntax)
        }
        s.Public = isPub(s.Ident)
        s.Fields = self.buildStructDeclFields(bodyTokens)
        s.End = tokens[i-1]
        ret s
    }

    fn checkMethodReceiver(mut self, &f: &FnDecl) {
        // Static methods cannot have receiver.
        if f.Statically {
            if len(f.Params) > 0 && f.Params[0].IsSelf() {
                self.pushErr(f.Token, LogMsg.StaticFnHasReceiver)
            }
            ret
        }
        if len(f.Params) == 0 {
            self.pushErr(f.Token, LogMsg.MissingReceiver)
            ret
        }
        let param = f.Params[0]
        if !param.IsSelf() {
            self.pushErr(f.Token, LogMsg.MissingReceiver)
            ret
        }
    }

    fn buildTraitBody(mut &self, mut &t: &TraitDecl, mut tokens: []&Token) {
        let mut stmts = splitStmts(tokens)
        for (_, mut stmt) in stmts {
            tokens = stmt.tokens
            if len(tokens) == 0 {
                continue
            }
            match tokens[0].Id {
            | TokenId.Fn:
                let mut f = self.buildFn(tokens, true, true)
                if f == nil {
                    break
                }
                if f.IsAnon() {
                    self.pushErr(f.Token, LogMsg.InvalidSyntax)
                }
                self.checkMethodReceiver(f)
                if len(f.Generics) > 0 {
                    self.pushErr(f.Token, LogMsg.TraitMethodHasGenerics)
                }
                t.Methods = append(t.Methods, f)
            |:
                let mut i = 0
                let (mut ti, ok) = unsafe { self.buildType(tokens, &i, true) }
                if !ok {
                    break
                }
                if i < len(tokens) {
                    self.pushErr(tokens[i], LogMsg.InvalidSyntax)
                }
                t.Inherits = append(t.Inherits, ti)
            }
        }
    }

    fn buildTraitDecl(mut &self, mut &tokens: []&Token): &TraitDecl {
        if len(tokens) < 3 {
            self.pushErr(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }
        let mut t = &TraitDecl{
            Token: tokens[1],
        }
        if t.Token.Id != TokenId.Ident {
            self.pushErr(t.Token, LogMsg.InvalidSyntax)
            self.pushSuggestion(LogMsg.ExpectedIdentifier)
        }
        t.Ident = t.Token.Kind
        let mut i = 2
        let mut bodyTokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if bodyTokens == nil {
            self.stop()
            self.pushErr(t.Token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret nil
        }
        if i < len(tokens) {
            self.pushErr(tokens[i], LogMsg.InvalidSyntax)
        }
        t.Public = isPub(t.Ident)
        self.buildTraitBody(t, bodyTokens)
        t.End = tokens[i-1]
        ret t
    }

    fn buildCppLinkFn(mut &self, mut tokens: []&Token): &FnDecl {
        tokens = tokens[1:] // Remove "cpp" keyword.
        let mut f = self.buildFn(tokens, false, true)
        if f != nil {
            if f.IsAnon() {
                self.pushErr(f.Token, LogMsg.InvalidSyntax)
            }
            f.Public = false
            f.CppLinked = true
        }
        ret f
    }

    fn buildCppLinkVar(mut &self, mut tokens: []&Token): &VarDecl {
        tokens = tokens[1:] // Remove "cpp" keyword.
        let mut v = self.buildVar(tokens)
        if v != nil {
            v.Public = false
            v.CppLinked = true
            if v.Expr != nil {
                self.pushErr(v.Token, LogMsg.CppLinkedVarHasExpr)
            }
        }
        ret v
    }

    fn buildCppLinkStruct(mut &self, mut tokens: []&Token): &StructDecl {
        tokens = tokens[1:] // Remove "cpp" keyword.
        let mut s = self.buildStructDecl(tokens)
        if s != nil {
            s.Public = false
            for (_, mut f) in s.Fields {
                // Linked structure's fields are always public by default.
                f.Public = true
            }
            s.CppLinked = true
        }
        ret s
    }

    fn buildCppLinkTypeAlias(mut &self, mut tokens: []&Token): &TypeAliasDecl {
        tokens = tokens[1:] // Remove "cpp" keyword.
        let mut t = self.buildTypeAliasDecl(tokens)
        if t != nil {
            t.Public = false
            t.CppLinked = true
        }
        ret t
    }

    fn buildCppLinkUse(mut &self, mut tokens: []&Token): &UseDecl {
        if len(tokens) == 1 {
            self.pushErr(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }
        tokens = tokens[1:] // Remove the "cpp" keyword.

        const CppLinked = true
        ret self.buildUseDecl(tokens, CppLinked)
    }

    fn buildCppLink(mut &self, mut &tokens: []&Token): NodeData {
        let mut token = tokens[0]
        if len(tokens) == 1 {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }
        token = tokens[1]
        match token.Id {
        | TokenId.Fn
        | TokenId.Unsafe:
            ret self.buildCppLinkFn(tokens)
        | TokenId.Const
        | TokenId.Let:
            ret self.buildCppLinkVar(tokens)
        | TokenId.Struct:
            ret self.buildCppLinkStruct(tokens)
        | TokenId.Type:
            ret self.buildCppLinkTypeAlias(tokens)
        |:
            self.pushErr(token, LogMsg.InvalidSyntax)
        }
        ret nil
    }

    fn getMethod(mut &self, mut &tokens: []&Token): &FnDecl {
        let mut i = 0
        let mut token = tokens[i]
        if token.Id == TokenId.Static {
            if i+1 >= len(tokens) {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret nil
            }
            i++
            token = tokens[i]
        }

        if token.Id == TokenId.Unsafe {
            if i+1 >= len(tokens) {
                self.pushErr(token, LogMsg.InvalidSyntax)
                ret nil
            }
            i++
            token = tokens[i]
        }

        if token.Id != TokenId.Fn {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut f = self.buildFn(tokens, true, false)
        if f != nil && f.IsAnon() {
            self.pushErr(f.Token, LogMsg.InvalidSyntax)
        }
        ret f
    }

    fn parseImplBody(mut &self, mut &ipl: &Impl, mut &tokens: []&Token) {
        let mut stmts = splitStmts(tokens)
        for (_, mut stmt) in stmts {
            tokens = stmt.tokens
            let mut token = tokens[0]
            match token.Id {
            | TokenId.Hash:
                self.pushDirective(self.buildDirective(tokens))
                continue
            }

            match token.Id {
            | TokenId.Const:
                let mut v = self.buildVar(tokens)
                if v != nil {
                    ipl.Statics = append(ipl.Statics, v)
                }
            | TokenId.Static
            | TokenId.Fn
            | TokenId.Unsafe:
                let mut f = self.getMethod(tokens)
                if f != nil {
                    self.checkMethodReceiver(f)
                    self.applyFnMeta(f)
                    ipl.Methods = append(ipl.Methods, f)
                }
            |:
                self.pushErr(token, LogMsg.InvalidSyntax)
                continue
            }
        }
    }

    fn buildImpl(mut &self, mut tokens: []&Token): &Impl {
        let mut token = tokens[0]
        if len(tokens) < 2 {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut i = 1

        let (mut base, mut ok) = unsafe { self.buildType(tokens, &i, true) }
        if !ok {
            ret nil
        }
        if i >= len(tokens) {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut ipl = &Impl{
            Base: base,
        }

        token = tokens[i]
        if token.Id != TokenId.For {
            if token.Id == TokenId.Range && token.Kind == TokenKind.LBrace {
                // This implementation is single.
                // Just implements to destination.
                // Therefore, swap Base and Dest tokens.
                ipl.Base, ipl.Dest = ipl.Dest, ipl.Base
                goto body
            }
            self.stop()
            self.pushErr(token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret nil
        }
        i++
        if i >= len(tokens) {
            self.stop()
            self.pushErr(token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret nil
        }

        ipl.Dest, ok = unsafe { self.buildType(tokens, &i, true) }
        if !ok {
            ret nil
        }
        if i >= len(tokens) {
            self.stop()
            self.pushErr(token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret nil
        }

    body:
        let mut bodyTokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if bodyTokens == nil {
            self.stop()
            self.pushErr(token, LogMsg.BodyNotExist)
            self.pushSuggestion(LogMsg.ExpectedBody)
            ret nil
        }
        if i < len(tokens) {
            self.pushErr(tokens[i], LogMsg.InvalidSyntax)
        }
        ipl.End = tokens[i-1]
        self.parseImplBody(ipl, bodyTokens)
        ret ipl
    }

    fn buildNodeData(mut &self, mut &tokens: []&Token): NodeData {
        let mut token = tokens[0]
        match token.Id {
        | TokenId.Fn
        | TokenId.Unsafe:
            let mut f = self.buildFn(tokens, false, false)
            if f != nil {
                f.Global = true
                if f.IsAnon() {
                    self.pushErr(f.Token, LogMsg.InvalidSyntax)
                }
            }
            ret f
        | TokenId.Let
        | TokenId.Const
        | TokenId.Mut
        | TokenId.Static:
            ret self.buildVar(tokens)
        | TokenId.Type:
            ret self.buildTypeAliasDecl(tokens)
        | TokenId.Enum:
            ret self.buildNodeEnumDecl(tokens)
        | TokenId.Struct:
            ret self.buildStructDecl(tokens)
        | TokenId.Trait:
            ret self.buildTraitDecl(tokens)
        | TokenId.Impl:
            ret self.buildImpl(tokens)
        | TokenId.Cpp:
            ret self.buildCppLink(tokens)
        |:
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    fn applyFnMeta(mut self, mut &f: &FnDecl) {
        f.Directives = self.directives
        self.directives = nil
    }

    fn applyMeta(mut self, mut &node: Node) {
        match type node.Data {
        | &VarDecl:
            let mut v = (&VarDecl)(node.Data)
            if v == nil {
                ret
            }
            v.Directives = self.directives
            self.directives = nil
        | &FnDecl:
            let mut f = (&FnDecl)(node.Data)
            if f == nil {
                ret
            }
            self.applyFnMeta(f)
        | &StructDecl:
            let mut sd = (&StructDecl)(node.Data)
            if sd == nil {
                ret
            }
            sd.Directives = self.directives
            self.directives = nil
        }
    }

    fn pushUseDecl(mut &self, mut &decl: &UseDecl) {
        self.ast.UseDecls = append(self.ast.UseDecls, decl)
        if len(self.ast.Nodes) > 0 {
            self.pushErr(decl.Token, LogMsg.UseDeclAtBody)
            self.pushSuggestion(LogMsg.MoveUseDeclToTopOfFile)
        }
    }

    fn pushMetaNodes(mut &self, mut &tokens: []&Token): bool {
        match tokens[0].Id {
        | TokenId.Use:
            const CppLinked = false
            let mut decl = self.buildUseDecl(tokens, CppLinked)
            self.pushUseDecl(decl)
            ret true
        | TokenId.Cpp:
            if len(tokens) > 1 && tokens[1].Id == TokenId.Use {
                let mut decl = self.buildCppLinkUse(tokens)
                self.pushUseDecl(decl)
                ret true
            }
        | TokenId.Hash:
            self.pushDirective(self.buildDirective(tokens))
            ret true
        }
        ret false
    }

    fn parseNode(mut &self, mut &st: []&Token): Node {
        let mut node = Node{
            Token: st[0],
        }

        if self.pushMetaNodes(st) {
            ret node
        }

        let mut data = self.buildNodeData(st)
        if data == nil {
            ret node
        }

        node.Data = data

        self.applyMeta(node)
        if len(self.directives) != 0 {
            self.pushErr(self.directives[0].Tag, LogMsg.UnusedDirective)
        }
        self.directives = nil
        ret node
    }

    fn appendNode(mut &self, mut &st: []&Token) {
        if len(st) == 0 {
            ret
        }
        let mut node = self.parseNode(st)
        if node.Data == nil || self.stopped() {
            ret
        }
        self.ast.Nodes = append(self.ast.Nodes, node)
    }

    fn removeRange(self, mut i: int, kind: str, &tokens: []&Token, mut &ranges: []int) {
        let close = getCloseKindOfBrace(kind)
        for i >= 0; i-- {
            let tok = tokens[ranges[i]]
            if tok.Kind != close {
                continue
            }
            ranges = append(ranges[:i], ranges[i+1:]...)
            break
        }
    }

    fn pushWrongOrderCloseErr(mut self, &t: &Token, &tokens: []&Token, &ranges: []int) {
        match tokens[ranges[len(ranges)-1]].Kind {
        | TokenKind.LParent:
            self.pushErr(t, LogMsg.ExpectedParentClose)
        | TokenKind.LBrace:
            self.pushErr(t, LogMsg.ExpectedBraceClose)
        | TokenKind.LBracket:
            self.pushErr(t, LogMsg.ExpectedBracketClose)
        }
    }

    fn pushRangeClose(mut self, t: &Token, left: str, &tokens: []&Token, mut &ranges: []int) {
        let n = len(ranges)
        if n == 0 {
            match t.Kind {
            | TokenKind.RBracket:
                self.pushErr(t, LogMsg.ExtraClosedBracket)
            | TokenKind.RBrace:
                self.pushErr(t, LogMsg.ExtraClosedBrace)
            | TokenKind.RParent:
                self.pushErr(t, LogMsg.ExtraClosedParent)
            }
            ret
        } else if tokens[ranges[n-1]].Kind != left {
            self.pushWrongOrderCloseErr(t, tokens, ranges)
        }
        self.removeRange(n - 1, t.Kind, tokens, ranges)
    }

    fn checkRanges(mut self, &tokens: []&Token) {
        let mut ranges: []int = nil

        for i, token in tokens {
            if token.Id != TokenId.Range {
                continue
            }
            match token.Kind {
            | TokenKind.LParent
            | TokenKind.LBrace
            | TokenKind.LBracket:
                ranges = append(ranges, i)
            | TokenKind.RParent:
                self.pushRangeClose(token, TokenKind.LParent, tokens, ranges)
            | TokenKind.RBrace:
                self.pushRangeClose(token, TokenKind.LBrace, tokens, ranges)
            | TokenKind.RBracket:
                self.pushRangeClose(token, TokenKind.LBracket, tokens, ranges)
            }
        }

        for _, i in ranges {
            let token = tokens[i]
            match token.Kind {
            | TokenKind.LParent:
                self.pushErr(token, LogMsg.WaitCloseParent)
            | TokenKind.LBrace:
                self.pushErr(token, LogMsg.WaitCloseBrace)
            | TokenKind.LBracket:
                self.pushErr(token, LogMsg.WaitCloseBracket)
            }
        }
    }

    fn parse(mut &self, mut &f: &File) {
        self.ast = &Ast{
            File: f,
        }

        self.checkRanges(f.Tokens)
        if len(self.errors) > 0 {
            ret
        }

        let mut stmts = splitStmts(f.Tokens)

        // Get top directives.
        let mut i = 0
        for i < len(stmts); i++ {
            let mut stmt = stmts[i]
            if len(stmt.tokens) < 2 {
                ret
            }
            if stmt.tokens[0].Id != TokenId.Hash {
                break
            }
            if !IsTopDirective(stmt.tokens[1].Kind) {
                break
            }
            self.ast.TopDirectives = append(self.ast.TopDirectives, self.buildDirective(stmt.tokens))
        }

        // Remove all errors.
        self.errors = nil

        for i < len(stmts); i++ {
            let mut stmt = stmts[i]
            self.appendNode(stmt.tokens)

            if self.stopped() {
                break
            }
        }

        if len(self.directives) != 0 {
            self.pushErr(self.directives[0].Tag, LogMsg.UnusedDirective)
        }
    }
}

fn isPub(&ident: str): bool {
    let (r, _) = utf8::DecodeRuneStr(ident)
    ret unicode::IsUpper(r)
}