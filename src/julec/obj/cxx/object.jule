// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use opt
use obj::{IR}
use conv for std::conv
use jule for std::jule
use build for std::jule::build::{
    Directive,
    Derive,
}
use std::jule::lex::{
    Token,
    TokenId,
    IsIgnoreIdent,
    IsAnonIdent,
}
use std::jule::sema::{
    FuncPattern,
    Package,
    SymbolTable,
    Param,
    ParamIns,
    Trait,
    Struct,
    FieldIns,
    Var,
    StructIns,
    Fn,
    FnIns,
    TypeKind,
    Prim,
    Sptr,
    TypeSymbol,
}
use path for std::fs::path
use strings for std::strings
use std::time::{Time}

// Data offset of empty trait.
const emptyTraitOffset = 0x0

const anyTypeIdent = "__jule_any_type"
const indentKind = "\t"

struct SerializationInfo {
    Compiler:        str
    CompilerCommand: str
}

struct traitHash {
    t: &Trait
    s: &StructIns
    i: int
}

struct traitCast {
    t1: &Trait
    t2: &Trait
}

struct ObjectCoder {
    // Internal buffer which is commonly used.
    Obj: str

    resultDecls: []str
    anyObj:      str

    ir:   &IR
    info: SerializationInfo
    tmap: []&traitHash

    // Current indentation.
    indentBuffer: str

    resultMap:    map[str]bool
    anyTypeMap:   []&TypeKind
    traitCastMap: []traitCast

    ec: &exprCoder
    sc: &scopeCoder
    tc: &typeCoder
    dc: &deriveCoder

    headPos: int
    declPos: int
}

impl ObjectCoder {
    static fn New(mut &ir: &IR, info: SerializationInfo): &ObjectCoder {
        let mut oc = &ObjectCoder{
            ir: ir,
            info: info,
        }
        oc.ec = exprCoder.new(oc)
        oc.sc = scopeCoder.new(oc)
        oc.tc = typeCoder.new(oc)
        oc.dc = deriveCoder.new(oc)
        ret oc
    }

    fn write(mut &self, s: str) {
        self.Obj += s
    }

    // Increase indentation.
    fn addIndent(mut &self) {
        self.indentBuffer += indentKind
    }

    // Decrase indentation.
    fn doneIndent(mut &self) {
        self.indentBuffer = self.indentBuffer[:len(self.indentBuffer)-1]
    }

    // Writes indention string by indentBuffer.
    fn indent(mut &self) {
        self.Obj += self.indentBuffer
    }

    fn findAnyType(mut &self, mut &t: &TypeKind): int {
        for (i, mut at) in self.anyTypeMap {
            if at.Equal(t) {
                ret i
            }
        }
        ret -1
    }

    fn pushAnyType(mut &self, mut &t: &TypeKind): int {
        let mut i = self.findAnyType(t)
        if i != -1 {
            ret i
        }
        i = len(self.anyTypeMap)
        self.anyTypeMap = append(self.anyTypeMap, t)
        let si = conv::Itoa(i)
        if t.Sptr() != nil {
            let elem_kind = self.tc.kind(t.Sptr().Elem)
            let kind = self.tc.asSptr(elem_kind)

            // dealloc function.
            self.anyObj += "void " + anyTypeIdent
            self.anyObj += si
            self.anyObj += "_dealloc(jule::Ptr<jule::Uintptr> &alloc) noexcept { alloc.__as<"
            self.anyObj += elem_kind
            self.anyObj += ">().dealloc(); }\n"

            // Type structure.
            self.anyObj += "struct " + typeCoder.Any + "::Type "
            self.anyObj += anyTypeIdent
            self.anyObj += si
            self.anyObj += "{.dealloc=" + anyTypeIdent
            self.anyObj += si
            self.anyObj += "_dealloc, .eq=jule::ptr_equal, .to_str=jule::ptr_to_str};\n"

            // comparison function.
            self.anyObj += typeCoder.Bool + " " + anyTypeIdent
            self.anyObj += si
            self.anyObj += "_compare(const " + typeCoder.Any + " &any, const "
            self.anyObj += kind
            self.anyObj += " &other) { return any.type == &" + anyTypeIdent
            self.anyObj += si
            self.anyObj += " && jule::ptr_equal(any.data.alloc, other.alloc); }\n"
        } else {
            let comparable = t.Comparable()
            let kind = self.tc.kind(t)
            if kind == "[<unimplemented_type_kind>]" {
                outln(t.Str())
            }

            // dealloc function.
            self.anyObj += "void " + anyTypeIdent
            self.anyObj += si
            self.anyObj += "_dealloc(jule::Ptr<jule::Uintptr> &alloc) noexcept { alloc.__as<"
            self.anyObj += kind
            self.anyObj += ">().dealloc(); }\n"

            if comparable {
                // eq function.
                self.anyObj += typeCoder.Bool + " " + anyTypeIdent
                self.anyObj += si
                self.anyObj += "_eq(void *alloc, void *other) noexcept { return *reinterpret_cast<"
                self.anyObj += kind
                self.anyObj += "*>(alloc) == *reinterpret_cast<"
                self.anyObj += kind
                self.anyObj += "*>(other); }\n"
            }

            // to_str function.
            self.anyObj += typeCoder.Str + " " + anyTypeIdent
            self.anyObj += si
            self.anyObj += "_to_str(const void *alloc) noexcept { return jule::to_str(*reinterpret_cast<"
            if t.Ptr() == nil {
                self.anyObj += "const "
                self.anyObj += kind
            } else {
                self.anyObj += kind
                self.anyObj += "* const"
            }
            self.anyObj += "*>(alloc)); }\n"

            // Type structure.
            self.anyObj += "struct " + typeCoder.Any + "::Type "
            self.anyObj += anyTypeIdent
            self.anyObj += si
            self.anyObj += "{.dealloc=" + anyTypeIdent
            self.anyObj += si
            self.anyObj += "_dealloc, "
            if comparable {
                self.anyObj += ".eq=" + anyTypeIdent
                self.anyObj += si
                self.anyObj += "_eq, "
            }
            self.anyObj += ".to_str=" + anyTypeIdent
            self.anyObj += si
            self.anyObj += "_to_str};\n"

            if comparable {
                // compare function.
                self.anyObj += typeCoder.Bool + " " + anyTypeIdent
                self.anyObj += si
                self.anyObj += "_compare(const " + typeCoder.Any + " &any, const "
                self.anyObj += kind
                self.anyObj += " &other) { return any.type == &" + anyTypeIdent
                self.anyObj += si
                self.anyObj += " && " + anyTypeIdent
                self.anyObj += si
                self.anyObj += "_eq(any.data.alloc, (void*)&other); }\n"
            }
        }
        ret i
    }

    fn pushResultIns(mut &self, mut &f: &FnIns) {
        let s = self.tc.rc.code(f.Result)
        let (_, ok) = self.resultMap[s]
        if ok {
            ret
        }
        self.resultMap[s] = false
        let mut obj = make(str, 0, 128)
        obj += "struct "
        obj += s
        obj += " {\n"
        for (i, mut t) in f.Result.Tup().Types {
            obj += indentKind
            obj += self.tc.kind(t)
            obj += " "
            obj += resultArgName
            obj += conv::Itoa(i)
            obj += ";\n"
        }
        obj += "};\n"
        self.resultDecls = append(self.resultDecls, obj)
    }

    fn pushResult(mut &self, mut &f: &Fn) {
        if f.IsVoid() || len(f.Result.Idents) <= 1 {
            ret
        }
        let mut n = len(f.Instances)
        if len(f.Generics) == 0 {
            n = 1
        }
        for (_, mut ins) in f.Instances[:n] {
            self.pushResultIns(ins)
        }
    }

    fn findTypeOffsetS(self, t: &Trait, mut s: &StructIns): int {
        if len(t.Implemented) == 0 {
            ret emptyTraitOffset
        }
        for _, hash in self.tmap {
            if hash.t == t && hash.s == s {
                ret hash.i
            }
        }
        ret -1
    }

    fn findTypeOffset(self, t: &Trait, mut k: &TypeKind): int {
        if len(t.Implemented) == 0 {
            ret emptyTraitOffset
        }
        let mut s: &StructIns = nil
        if k.Sptr() != nil {
            k = k.Sptr().Elem
        }
        s = k.Struct()
        if s == nil {
            ret -1
        }
        ret self.findTypeOffsetS(t, s)
    }

    fn pushAndWriteMaskMapper(mut &self, mut t1: &Trait, mut t2: &Trait) {
        let mut ident = "__jule_trait_offset_mapper_"
        ident += conv::FmtUint(u64(uintptr(t2)), 0xF)
        ident += "_to_"
        ident += conv::FmtUint(u64(uintptr(t1)), 0xF)
        self.write(ident)

        // Lookup and push if this match is not exist.
        for _, m in self.traitCastMap {
            if m.t1 == t1 && m.t2 == t2 {
                ret
            }
        }

        self.traitCastMap = append(self.traitCastMap, traitCast{t1: t1, t2: t2})

        // Not exist, push.
        //
        // TODO:
        //  As partially confirmed by the experiments, the same mapping conditions
        //  apply for two traits that casting into each other. It was decided that
        //  additional investigation was needed to conclusively confirm this.
        const offset = "offset"
        self.anyObj += typeCoder.Int
        self.anyObj += " "
        self.anyObj += ident
        self.anyObj += "(const " + typeCoder.Int + " " + offset + ") noexcept { "
        for (_, mut s1) in t1.Implemented {
            for _, s2 in t2.Implemented {
                if s1 == s2 {
                    for (_, mut s1i) in s1.Instances {
                        let i1 = self.findTypeOffsetS(t1, s1i)
                        let i2 = self.findTypeOffsetS(t2, s1i)
                        self.anyObj += "if (offset == "
                        self.anyObj += conv::Itoa(i2)
                        self.anyObj += ") return "
                        self.anyObj += conv::Itoa(i1)
                        self.anyObj += "; "
                    }
                }
            }
        }
        self.anyObj += " return "
        self.anyObj += conv::Itoa(emptyTraitOffset)
        self.anyObj += "; }\n"
    }

    // Writes location information of token as cstr bytes.
    fn locInfo(mut &self, &t: &Token) {
        let &loc = t.File.Path

        // Normalize path if production compilation enabled.
        if env::Production {
            match {
            | strings::HasPrefix(loc, build::PathStdlib):
                // Remove absolute path prefix of standard library.
                // Just keeps "std/" prefix.
                self.write(cstrBytes([]byte(loc[len(path::Dir(build::PathStdlib))+1:])))
            | strings::HasPrefix(loc, self.ir.Root):
                // Remove absolute path prefix of root package.
                // Just keeps "[package_dir]/" prefix.
                self.write(cstrBytes([]byte(loc[len(path::Dir(self.ir.Root))+1:])))
            |:
                self.write(cstrBytes([]byte(loc)))
            }
        } else {
            self.write(cstrBytes([]byte(loc)))
        }
        self.write(":")
        self.write(conv::Itoa(t.Row))
        self.write(":")
        self.write(conv::Itoa(t.Column))
    }

    fn head(mut &self) {
        let time = Time.Now()
        let abs = time.Abs()
        self.write("// Auto generated by JuleC.\n")
        self.write("// JuleC version: ")
        self.write(jule::Version)
        self.write("\n")
        self.write("// Date: ")
        self.write(conv::FmtUint(abs.Day, 10))
        self.write("/")
        self.write(conv::FmtUint(abs.Month, 10))
        self.write("/")
        self.write(conv::FmtUint(abs.Year, 10))
        self.write(" (DD/MM/YYYY) UTC\n//\n// Recomended Compile Command;\n// ")
        self.write(self.info.Compiler)
        self.write(" ")
        self.write(self.info.CompilerCommand)
        self.write("\n\n")

        if env::Production {
            self.write("#define __JULE_ENABLE__PRODUCTION\n")
        }
        if !env::RC {
            self.write("#define __JULE_DISABLE__REFERENCE_COUNTING\n")
        }
        if !env::Safety {
            self.write("#define __JULE_DISABLE__SAFETY\n")
        }

        // Include linked libraries here, before the API header.
        // See developer reference (4).
        self.links()

        self.write("\n\n#include \"")
        self.write(build::PathApi)
        self.write("\"\n\n")
    }

    fn links(mut &self) {
        for _, used in self.ir.Used {
            match {
            | !used.CppLinked:
                continue
            | build::IsStdHeaderPath(used.Path):
                self.write("#include ")
                self.write(used.Path)
                self.write("\n")
            | build::IsValidHeaderExt(path::Ext(used.Path)):
                self.write("#include \"")
                self.write(used.Path)
                self.write("\"\n")
            }
        }
    }

    fn prepareStructure(mut self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            for (_, mut m) in ins.Methods {
                if m.Statically {
                    continue
                }
                for (_, mut mins) in m.Instances {
                    let mut p = mins.Params[0]
                    if !p.Decl.IsRef() {
                        p.Kind = &TypeKind{
                            Kind: &customType{
                                kind: self.tc.asPtr(self.tc.kind(p.Kind)),
                            },
                        }
                    } else {
                        p.Kind = &TypeKind{
                            Kind: &customType{
                                kind: self.tc.kind(p.Kind),
                            },
                        }
                    }
                }
            }
        }
    }

    fn prepareStructures(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.prepareStructure(s)
            }
        }
    }

    fn iterPackages(mut &self, f: fn(mut &pkg: &Package)) {
        for (_, mut used) in self.ir.Used {
            if !used.CppLinked {
                f(used.Package)
            }
        }
        f(self.ir.Main)
    }

    fn buildTraitMap(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    if len(t.Implemented) == 0 {
                        self.tmap = append(self.tmap, &traitHash{
                            t: t,
                            s: nil,
                            i: emptyTraitOffset,
                        })
                        continue
                    }
                    let mut i = 0
                    for (_, mut s) in t.Implemented {
                        for (_, mut ins) in s.Instances {
                            self.tmap = append(self.tmap, &traitHash{
                                t: t,
                                s: ins,
                                i: i,
                            })
                            i++
                        }
                    }
                    // Push all methods to t from t's inheritances.
                    // Because they will be used for trait data generation.
                    pushMethodsFromInherits(t, t)
                }
            })
        })
    }

    fn traitDecls(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    self.indent()
                    self.write("struct ")
                    self.write(identCoder.traitDecl(t))
                    self.write("{};\n")
                }
            })
        })
    }

    fn structurePlainDecl(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.write("struct ")
            self.write(identCoder.structureIns(ins))
            self.write(";\n")
        }
    }

    fn structurePlainDecls(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structurePlainDecl(s)
            }
        }
    }

    fn fieldDecl(mut &self, mut &f: &FieldIns) {
        self.write(self.tc.kind(f.Kind))
        self.write(" ")
        self.write(identCoder.field(f.Decl))
        if f.Default == nil {
            if shouldInitialized(f.Kind) {
                self.write(" = ")
                // No default expression.
                // Use default expression of data-type.
                self.ec.initExpr(f.Kind)
            }
        } else {
            self.write(" = ")
            self.ec.possibleRefExpr(f.Default.Model)
        }
        self.write(";")
    }

    fn structureDestructor(mut &self, mut &s: &StructIns) {
        // Dispose method must be non-static
        const Static = false
        let disposeMethod = s.FindMethod("Dispose", Static)
        let mut disposed = FuncPattern.Dispose(disposeMethod)
        // Call destructor if implemented.
        if !disposed {
            ret
        }
        self.write("~")
        self.write(identCoder.structureIns(s))
        self.write("(void) { ")
        self.write(identCoder.func(disposeMethod))
        self.write("(this); }")
    }

    fn structureDeriveDefsDecls(mut &self, &s: &StructIns) {
        if s.Decl.IsDerives(Derive.Clone) {
            self.indent()
            self.write(self.dc.cloneFuncDecl(s.Decl))
            self.write(";\n\n")
        }
    }

    fn structureOperatorEq(mut &self, &ident: str, mut &s: &StructIns) {
        if !s.Comparable {
            ret
        }
        // Operator overloading.
        if s.Operators.Eq != nil {
            self.structureOperator(ident, s.Operators.Eq, "==")
            ret
        }

        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        self.write("bool operator==(")
        self.write(ident)
        self.write(" _other) {")
        if len(s.Fields) > 0 {
            self.addIndent()
            self.write("\n")
            self.indent()
            self.write("return ")
            self.addIndent()
            let mut writed = false
            for (_, mut f) in s.Fields {
                // Skip C++-linked struct kinds.
                let strct = f.Kind.Struct()
                if strct != nil && strct.Decl != nil && strct.Decl.CppLinked {
                    continue
                }
                if writed {
                    self.write(" &&")
                }
                writed = true
                self.write("\n")
                self.indent()
                self.write("this->")
                let fIdent = identCoder.field(f.Decl)
                self.write(fIdent)
                self.write(" == _other.")
                self.write(fIdent)
            }
            self.doneIndent()
            if !writed {
                self.write("true")
            }
            self.write(";\n")
            self.doneIndent()
            self.indent()
            self.write("}")
        } else {
            self.write(" return true; }")
        }
        self.write("\n\n")
    }

    fn structureOperatorNotEq(mut &self, &ident: str, mut &s: &StructIns) {
        if !s.Comparable {
            ret
        }
        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        self.write("bool operator!=(")
        self.write(ident)
        self.write(" _other) { return !this->operator==(_other); }\n\n")
    }

    // Write operator overloading forwarding for reserved function.
    fn structureOperator(mut &self, &ident: str, mut &f: &FnIns, op: str) {
        if f == nil {
            ret
        }

        let unary = len(f.Params) == 1   // Just self parameter.
        let assignment = f.Decl.IsVoid()

        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        if assignment {
            self.write(ident)
            self.write("&")
        } else {
            if f.Result.Prim() == nil {
                // If result type is not primitive, always structure's itself.
                self.write(ident)
            } else {
                // Logical.
                self.write(typeCoder.Bool)
            }
        }
        self.write(" operator")
        self.write(op)
        self.write("(")
        if !unary {
            let mut p = f.Params[1]
            self.write(self.tc.paramIns(p))
            self.write(" _other")
        }
        self.write(") { ")
        if !assignment {
            self.write("return ")
        }
        self.write(identCoder.funcIns(f))
        if !unary {
            self.write("(this, _other); ")
            if assignment {
                self.write("return *this; ")
            }
            self.write("}")
        } else {
            self.write("(this); }")
        }
        self.write("\n\n")
    }

    fn structureOperators(mut &self, mut &s: &StructIns) {
        let ident = identCoder.structureIns(s)

        // Binary.
        self.structureOperatorEq(ident, s)
        self.structureOperatorNotEq(ident, s)
        self.structureOperator(ident, s.Operators.Gt, ">")
        self.structureOperator(ident, s.Operators.GtEq, ">=")
        self.structureOperator(ident, s.Operators.Lt, "<")
        self.structureOperator(ident, s.Operators.LtEq, "<=")
        self.structureOperator(ident, s.Operators.Shl, "<<")
        self.structureOperator(ident, s.Operators.Shr, ">>")
        self.structureOperator(ident, s.Operators.Add, "+")
        self.structureOperator(ident, s.Operators.Sub, "-")
        self.structureOperator(ident, s.Operators.Div, "/")
        self.structureOperator(ident, s.Operators.Mul, "*")
        self.structureOperator(ident, s.Operators.Mod, "%")
        self.structureOperator(ident, s.Operators.BitAnd, "&")
        self.structureOperator(ident, s.Operators.BitOr, "|")
        self.structureOperator(ident, s.Operators.BitXor, "^")

        // Unary.
        self.structureOperator(ident, s.Operators.Neg, "-")
        self.structureOperator(ident, s.Operators.Pos, "+")
        self.structureOperator(ident, s.Operators.BitNot, "~")

        // Assignment.
        self.structureOperator(ident, s.Operators.AddAssign, "+=")
        self.structureOperator(ident, s.Operators.SubAssign, "-=")
        self.structureOperator(ident, s.Operators.DivAssign, "/=")
        self.structureOperator(ident, s.Operators.MulAssign, "*=")
        self.structureOperator(ident, s.Operators.ModAssign, "%=")
        self.structureOperator(ident, s.Operators.ShlAssign, "<<=")
        self.structureOperator(ident, s.Operators.ShrAssign, ">>=")
        self.structureOperator(ident, s.Operators.BitOrAssign, "|=")
        self.structureOperator(ident, s.Operators.BitAndAssign, "&=")
        self.structureOperator(ident, s.Operators.BitXorAssign, "^=")
    }

    fn structureInsDecl(mut &self, mut &s: &StructIns) {
        if len(s.Methods) > 0 {
            for (_, mut m) in s.Methods {
                self.pushResult(m)
                self.funcDecl(m, false)
            }
        }

        self.write("struct ")
        let outIdent = identCoder.structureIns(s)

        self.write(outIdent)
        self.write(" {\n")

        self.addIndent()
        for (_, mut f) in s.Fields {
            self.indent()
            self.fieldDecl(f)
            self.write("\n")
        }

        self.indent()
        self.structureDestructor(s)
        self.write("\n\n")

        // Default constructor.
        self.indent()
        self.write(outIdent)
        self.write("(void) = default;\n\n")

        self.structureDeriveDefsDecls(s)

        self.structureOperators(s)
        self.write("\n")

        self.doneIndent()
        self.indent()
        self.write("};")
    }

    fn structureDecl(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.structureInsDecl(ins)
        }
    }

    fn structureDecls(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structureDecl(s)
                self.write("\n")
            }
        }
    }

    fn paramsDecls(mut &self, mut &params: []&ParamIns) {
        if len(params) == 0 {
            self.write("(void)")
            ret
        }

        self.write("(")
        for (i, mut p) in params {
            self.write(self.tc.paramIns(p))
            if len(params)-i > 1 {
                self.write(", ")
            }
        }

        self.write(")")
    }

    fn funcHead(mut &self, mut &f: &FnIns, ptr: bool) {
        if !ptr && opt::Inline && !f.Decl.IsEntryPoint() {
            self.write("inline ")
        }
        self.tc.funcInsResult(self.Obj, f)
        if ptr {
            self.write("(*")
            self.write(identCoder.funcIns(f))
            self.write(")")
        } else {
            self.write(" ")
            self.write(identCoder.funcIns(f))
        }
    }

    fn funcDeclIns(mut &self, mut &f: &FnIns, ptr: bool) {
        self.indent()
        self.funcHead(f, ptr)
        self.paramsDecls(f.Params)
        self.write(";\n")
    }

    fn funcDecl(mut &self, mut &f: &Fn, ptr: bool) {
        for (_, mut c) in f.Instances {
            self.funcDeclIns(c, ptr)
        }
    }

    fn funcDeclTrait(mut &self, mut &t: &Trait, mut &f: &Fn, ptr: bool) {
        for (_, mut c) in f.Instances {
            let mut k = c.Params[0].Kind
            c.Params[0].Kind = &TypeKind{Kind: t}
            self.funcDeclIns(c, ptr)
            c.Params[0].Kind = k
        }
    }

    fn funcDecls(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut f) in file.Funcs {
                    if !f.CppLinked && f.Token != nil {
                        self.pushResult(f)
                        self.funcDecl(f, false)
                    }
                }
            })
        })
    }

    fn traitDataTypeMethods(mut &self, mut &owner: &Trait, mut &t: &Trait) {
        for (_, mut m) in t.Methods {
            let mut ins = m.Instances[0]
            let mut p = ins.Params[0]
            p.Kind = &TypeKind{
                Kind: t,
            }
            for (i, mut ip) in ins.Params[1:] {
                if IsAnonIdent(ip.Decl.Ident) {
                    ip.Decl.Ident = "_" + conv::Itoa(i)
                }
            }
            if !env::Production {
                let mut lp = ins.Params[len(ins.Params)-1]
                match type lp.Kind.Kind {
                | &customType:
                    break
                |:
                    ins.Params = append(ins.Params, &ParamIns{
                        Decl: &Param{
                            Ident: "__file",
                        },
                        Kind: &TypeKind{
                            Kind: &customType{
                                kind: "const char*",
                            },
                        },
                    })
                }
            }
            self.pushResult(m)
            self.funcDeclTrait(owner, m, true)
        }
    }

    fn traitDataTypes(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    if len(t.Methods) == 0 {
                        continue
                    }
                    self.write("struct ")
                    self.write(identCoder.traitDecl(t))
                    self.write("MptrData")
                    self.write(" {\n")
                    self.addIndent()
                    self.traitDataTypeMethods(t, t)
                    self.doneIndent()
                    self.indent()
                    self.write("};\n\n")
                }
            })
        })
    }

    fn paramIns(mut &self, mut &p: &ParamIns) {
        self.write(self.tc.paramIns(p))
        self.write(" ")
        self.write(identCoder.param(p.Decl))
    }

    fn paramsIns(mut &self, mut &params: []&ParamIns) {
        if len(params) == 0 {
            self.write("(void)")
            ret
        }
        self.write("(")
        for (i, mut p) in params {
            self.paramIns(p)
            if len(params)-i > 1 {
                self.write(", ")
            }
        }
        self.write(")")
    }

    fn varInitExpr(mut &self, mut &v: &Var, init: fn()) {
        if v.Statically {
            self.write("static ")
        }

        self.write(self.tc.kind(v.Kind.Kind))
        self.write(" ")
        if v.Reference {
            self.write("*")
        }
        self.write(identCoder.var(v))
        if init != nil {
            self.write(" = ")
            init()
        }
        self.write(";")
    }

    fn var(mut &self, mut v: &Var) {
        if IsIgnoreIdent(v.Ident) {
            ret
        }
        if v.Value != nil && v.Value.Expr != nil {
            if v.Value.Data.Model != nil {
                if v.Reference {
                    self.varInitExpr(v, fn() {
                        self.write("&(")
                        self.ec.model(v.Value.Data.Model)
                        self.write(")")
                    })
                } else {
                    self.varInitExpr(v, fn() { self.ec.possibleRefExpr(v.Value.Data.Model) })
                }
                ret
            }
            self.varInitExpr(v, nil)
            ret
        }
        if v.Reference {
            self.varInitExpr(v, fn() { self.write("nullptr") })
            ret
        }
        if shouldInitialized(v.Kind.Kind) {
            self.varInitExpr(v, fn() { self.ec.initExpr(v.Kind.Kind) })
            ret
        }
        self.varInitExpr(v, nil)
    }

    fn funcIns(mut &self, mut &f: &FnIns) {
        self.funcHead(f, false)
        self.paramsIns(f.Params)
        self.write(" ")
        self.sc.funcScope(f)
        if f.Scope != nil {
            self.write("\n\n")
        }
    }

    fn func(mut &self, mut &f: &Fn) {
        for (_, mut ins) in f.Instances {
            self.funcIns(ins)
        }
    }

    fn funcTrait(mut &self, mut &hash: &traitHash, mut &f: &Fn) {
        let ident = f.Ident
        for (_, mut ins) in f.Instances {
            ins.Scope = nil

            f.Ident = ident
            f.Ident += "_"
            f.Ident += hash.t.Ident
            f.Ident += "_"
            f.Ident += conv::Itoa(hash.i)

            let mut k = ins.Params[0].Kind
            ins.Params[0].Kind = &TypeKind{Kind: hash.t}
            self.funcIns(ins)
            ins.Params[0].Kind = k
        }
        f.Ident = ident
    }

    fn traitWrapper(mut &self, mut &m: &Fn, mut &hash: &traitHash) {
        self.funcTrait(hash, m)

        if hash.s == nil {
            if env::Production {
                self.write(" { jule::panic(__JULE_ERROR__INVALID_MEMORY); }\n")
            } else {
                self.write(" { jule::panic(" + typeCoder.Str + "(__JULE_ERROR__INVALID_MEMORY \"\\nlocation: \") + " + typeCoder.Str + "(_00___file)); }\n")
            }
            ret
        }

        let ptr = !m.Params[0].IsRef()

        let mut sm = hash.s.FindMethod(m.Ident, false)
        if sm == nil || len(sm.Instances) == 0 {
            ret
        }

        self.addIndent()
        self.write("{\n")
        self.indent()
        if sm.Exceptional || !sm.IsVoid() {
            self.write("return ")
        }
        self.write(identCoder.func(sm))
        self.write("(")
        if ptr {
            self.write("_self_.safe_ptr<")
            self.write(self.tc.structureIns(hash.s))
            self.write(">(")
            if !env::Production {
                self.write("_00___file")
            }
            self.write(")")
        } else {
            self.write("_self_.data.as<")
            self.write(self.tc.structure(sm.Owner))
            self.write(">()")
        }
        for _, mp in m.Params[1:] {
            self.write(", ")
            self.write(identCoder.param(mp))
        }
        self.write(");\n}\n")
        self.doneIndent()
    }

    fn traitWrappers(mut &self) {
        for (_, mut hash) in self.tmap {
            for (_, mut m) in hash.t.Methods {
                self.traitWrapper(m, hash)
            }
        }
    }

    fn traitDataMethods(mut &self, mut &t: &Trait, &hash: &traitHash) {
        for (_, mut m) in t.Methods {
            let mIdent = identCoder.func(m)
            self.indent()
            self.write(".")
            self.write(mIdent)
            self.write("=")
            self.write(mIdent)
            self.write("_")
            self.write(hash.t.Ident)
            self.write("_")
            self.write(conv::Itoa(hash.i))
            self.write(",\n")
        }
    }

    fn traitData(mut &self, mut &hash: &traitHash, mut &old: &Trait) {
        if len(hash.t.Methods) == 0 {
            ret
        }
        let ident = identCoder.traitDecl(hash.t)
        if hash.t != old {
            if old != nil {
                self.doneIndent()
                self.indent()
                self.write("};\n")
            }
            self.write("static ")
            self.write(ident)
            self.write("MptrData ")
            self.write(ident)
            self.write("_mptr_data[] = {\n")
            old = hash.t
            self.addIndent()
        }
        self.indent()
        self.write("{\n")
        self.addIndent()
        self.traitDataMethods(hash.t, hash)
        self.doneIndent()
        self.indent()
        self.write("},\n")
    }

    fn traitDatas(mut &self) {
        let mut old: &Trait = nil
        for (_, mut hash) in self.tmap {
            self.traitData(hash, old)
        }
        if old != nil {
            self.doneIndent()
            self.indent()
            self.write("};\n")
        }
    }

    fn globals(mut &self) {
        for (_, mut v) in self.ir.Ordered.Globals {
            self.write(self.tc.kind(v.Kind.Kind))
            self.write(" ")
            self.write(identCoder.var(v))
            self.write(" = ")
            self.ec.model(v.Value.Data.Model)
            self.write(";\n")
        }
    }

    fn decls(mut &self) {
        self.traitDecls()
        self.structurePlainDecls()
        self.headPos = len(self.Obj)
        self.structureDecls()
        self.funcDecls()
        self.write("\n\n")
        self.traitDataTypes()
        self.write("\n\n")
        self.traitWrappers()
        self.write("\n\n")
        self.traitDatas()
        self.write("\n\n")
        self.declPos = len(self.Obj)
        self.globals()
    }

    fn structureMethods(mut &self, mut &s: &StructIns) {
        for (_, mut f) in s.Methods {
            self.func(f)
            self.write("\n\n")
        }
    }

    fn structureDeriveDefs(mut &self, mut &s: &StructIns) {
        if s.Decl.IsDerives(Derive.Clone) {
            self.write(self.dc.cloneFuncDef(s.Decl))
            self.write("{\n")
            self.addIndent()
            self.indent()
            self.write(self.tc.structureIns(s))
            self.write(" clone;\n")
            for _, f in s.Fields {
                let ident = identCoder.field(f.Decl)
                self.indent()
                self.write("clone.")
                self.write(ident)
                self.write(" = jule::clone(this->")
                self.write(ident)
                self.write(");\n")
            }
            self.indent()
            self.write("return clone;\n")
            self.doneIndent()
            self.write("}")
        }
    }

    fn structureOstream(mut &self, mut &s: &StructIns) {
        self.indent()
        self.write("std::ostream &operator<<(std::ostream &_Stream, ")
        self.write(identCoder.structureIns(s))
        self.write(" _Src) {\n")
        self.addIndent()
        self.indent()

        let mut fts = s.FindMethod("Str", false)
        if FuncPattern.Str(fts) {
            self.write("_Stream << ")
            self.write(identCoder.func(fts))
            self.write("(&_Src);\n")
        } else {
            self.write(`_Stream << "`)
            self.write(s.Decl.Ident)
            self.write("{\";\n")

            for (i, mut f) in s.Fields {
                self.indent()
                self.write(`_Stream << "`)
                self.write(f.Decl.Ident)
                self.write(`:`)

                // Skip C++-linked struct kinds.
                let strct = f.Kind.Struct()
                if strct != nil && strct.Decl != nil && strct.Decl.CppLinked {
                    self.write(` cpp.`)
                    self.write(identCoder.field(f.Decl))
                    self.write(`"`)
                } else {
                    self.write(`" << _Src.`)
                    self.write(identCoder.field(f.Decl))
                }
                if i+1 < len(s.Fields) {
                    self.write(" << \", \"")
                }
                self.write(";\n")
            }

            self.indent()
            self.write("_Stream << \"}\";\n")
        }

        self.indent()
        self.write("return _Stream;\n")

        self.doneIndent()
        self.write("}")
    }

    fn structureIns(mut &self, mut &s: &StructIns) {
        self.structureMethods(s)
        self.write("\n\n")
        self.structureDeriveDefs(s)
        self.write("\n\n")
        self.structureOstream(s)
    }

    fn structure(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.structureIns(ins)
            self.write("\n\n")
        }
    }

    fn structures(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structure(s)
                self.write("\n\n")
            }
        }
    }

    fn funcs(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut f) in file.Funcs {
                    if !env::Test && hasDirective(f.Directives, Directive.Test) {
                        continue
                    }
                    if !f.CppLinked && f.Token != nil {
                        self.func(f)
                        self.write("\n\n")
                    }
                }
            })
        })
    }

    fn pushInit(mut &self, mut &pkg: &Package) {
        iterFiles(pkg, fn(mut &file: &SymbolTable) {
            for _, f in file.Funcs {
                if f.Ident == build::InitFn {
                    self.indent()
                    self.write(identCoder.func(f))
                    self.write("();\n")
                }
            }
        })
    }

    fn initCaller(mut &self) {
        self.write("void " + initCallerIdent + "(void) {\n")
        self.addIndent()
        self.iterPackages(fn(mut &pkg: &Package) {
            self.pushInit(pkg)
        })
        self.doneIndent()
        self.write("\n}")
    }

    fn end(mut &self) {
        self.write(`int main(int argc, char *argv[], char *envp[]) {
    jule::setup_argv(argc, argv);
    jule::setup_envp(envp);

    __jule_call_initializers();
    `)

        if env::Test {
            self.write("test_point();")
        } else {
            self.write("entry_point();")
        }

        self.write(`

    return EXIT_SUCCESS;
}`)
    }

    fn serializeHead(mut &self) {
        self.prepareStructures()
        self.buildTraitMap()
        self.head()
        self.write("\n")
        self.decls()

        if len(self.resultDecls) > 0 {
            let mut head = self.Obj[:self.headPos]
            for _, decl in self.resultDecls {
                head += decl
                self.declPos += len(decl)
            }
            head += self.Obj[self.headPos:]
            self.Obj = head
        }

        self.write("\n")
        self.structures()
        self.funcs()
        self.initCaller()
        self.write("\n\n")

        if len(self.anyObj) > 0 {
            let mut head = self.Obj[:self.declPos]
            head += self.anyObj
            head += self.Obj[self.declPos:]
            self.Obj = head
        }
    }

    fn Serialize(mut &self) {
        self.serializeHead()
        self.end()
    }
}

fn iterFiles(mut &pkg: &Package, f: fn(mut &f: &SymbolTable)) {
    for (_, mut file) in pkg.Files {
        f(file)
    }
}

// Concatenate all strings into single string.
fn concatAllParts(parts: ...&Token): str {
    let mut n = 0
    for _, part in parts {
        n += len(part.Kind)
    }
    if n == 0 {
        ret ""
    }
    let mut s = make(str, 0, n)
    for _, p in parts {
        s += p.Kind
    }
    ret s
}

// Reports whether trait have method in this identifier.
fn containsTraitMethod(mut &t: &Trait, &ident: str): bool {
    for _, m in t.Methods {
        if m.Ident == ident {
            ret true
        }
    }
    ret false
}

// Pushes src methods to dest if not exist any method with relevant identifier.
// Also it uses deep walk algorithm for inheritances.
// So it will pushes inheritances of src trait to dest.
fn pushMethodsFromInherit(mut &dest: &Trait, mut &src: &Trait) {
    pushMethodsFromInherits(dest, src)
    for (_, mut m) in src.Methods {
        if !containsTraitMethod(dest, m.Ident) {
            dest.Methods = append(dest.Methods, m)
        }
    }
}

// Pushes inheritances of src to dest.
// Call pushMethodsFromInherit method per inheritance of src.
fn pushMethodsFromInherits(mut &dest: &Trait, mut &src: &Trait) {
    for (_, mut inh) in src.Inherits {
        let mut t2 = inh.Kind.Trait()
        pushMethodsFromInherit(dest, t2)
    }
}