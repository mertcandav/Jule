// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use math for std::math
use std::jule::constant::{Const}
use std::jule::lex::{TokenKind}
use std::jule::sema::{
    Scope,
    Data,
    Var,
    FnIns,
    ExprModel,
    BinopExprModel,
    OperandExprModel,
    UnaryExprModel,
    StructLitExprModel,
    AllocStructLitExprModel,
    CastingExprModel,
    FnCallExprModel,
    SliceExprModel,
    ArrayExprModel,
    IndexingExprModel,
    AnonFnExprModel,
    MapExprModel,
    SlicingExprModel,
    TraitSubIdentExprModel,
    StructSubIdentExprModel,
    CommonSubIdentExprModel,
    TupleExprModel,
    BuiltinNewCallExprModel,
    BuiltinOutCallExprModel,
    BuiltinOutlnCallExprModel,
    BuiltinPanicCallExprModel,
    BuiltinAssertCallExprModel,
    BuiltinErrorCallExprModel,
    BuiltinMakeCallExprModel,
    BuiltinAppendCallExprModel,
    BuiltinLenCallExprModel,
    BuiltinCapCallExprModel,
    BuiltinCloneCallExprModel,
    BuiltinDeleteCallExprModel,
    SizeofExprModel,
    AlignofExprModel,
    IntegratedToStrExprModel,
    FreeExprModel,
    BackendEmitExprModel,
}
use types for std::jule::types

// Expression optimizer that applies target-independent optimizations.
struct exprOptimizer {
    mut model: &ExprModel
}

impl exprOptimizer {
    static fn optimize(mut &model: ExprModel) {
        // Do optimizatitons if any enabled.
        if exprEnabled {
            let mut exop = &exprOptimizer{
                model: unsafe { (&ExprModel)(&model) },
            }
            exop.do()
        }
    }

    fn strCond(self, mut m: &BinopExprModel): bool {
        let lp = m.Left.Kind.Prim()
        if lp == nil || !lp.IsStr() {
            ret false
        }
        if m.Op.Kind != TokenKind.Eqs && m.Op.Kind != TokenKind.NotEq {
            ret false
        }
        match type m.Left.Model {
        | &Const:
            m.Left, m.Right = m.Right, m.Left
            goto opt
        }
        match type m.Right.Model {
        | &Const:
            break
        |:
            ret true
        }
    opt:
        let mut c = (&Const)(m.Right.Model)
        match m.Op.Kind {
        | TokenKind.Eqs:
            if c.ReadStr() == "" {
                *self.model = &CommonSubIdentExprModel{
                    ExprKind: m.Left.Kind,
                    Expr: m.Left.Model,
                    Ident: "empty()",
                }
                break
            }
            let mut model = any(&StrCompExprModel{
                Left: m.Left.Model,
                Right: c,
                NotEq: false,
            })
            *self.model = unsafe { *(*ExprModel)(&model) }
        | TokenKind.NotEq:
            if c.ReadStr() == "" {
                let mut op = m.Op
                op.Kind = TokenKind.Excl
                *self.model = &UnaryExprModel{
                    Op: op,
                    Expr: &Data{
                        Model: &CommonSubIdentExprModel{
                            ExprKind: m.Left.Kind,
                            Expr: m.Left.Model,
                            Ident: "empty()",
                        },
                    },
                }
                break
            }
            let mut model = any(&StrCompExprModel{
                Left: m.Left.Model,
                Right: c,
                NotEq: true,
            })
            *self.model = unsafe { *(*ExprModel)(&model) }
        }
        ret true
    }

    fn binary(self, mut m: &BinopExprModel) {
        exprOptimizer.optimize(m.Left.Model)
        exprOptimizer.optimize(m.Right.Model)

        match type m.Right.Model {
        | &Const:
            break
        |:
            ret
        }

        if Cond && self.strCond(m) {
            ret
        }

        if !Math {
            ret
        }
        match m.Op.Kind {
        | TokenKind.Star:
            let (ok, x) = checkForBitShiftOpt(m.Left, m.Right)
            if ok {
                m.Op.Kind = TokenKind.Lshift
                let mut c = (&Const)(m.Right.Model)
                c.SetU64(x)
                ret
            }
        | TokenKind.Solidus:
            let (ok, x) = checkForBitShiftOpt(m.Left, m.Right)
            if ok {
                m.Op.Kind = TokenKind.Rshift
                let mut c = (&Const)(m.Right.Model)
                c.SetU64(x)
                ret
            }
        | TokenKind.Percent:
            let mut c = (&Const)(m.Right.Model)
            let d = c.AsF64()
            if d == 2 {
                m.Op.Kind = TokenKind.Amper
                c.SetI64(1)
            }
        }
        let mut model: any = &UnsafeBinopExprModel{Node: m}
        *self.model = unsafe { *(*ExprModel)(&model) }
    }

    fn unary(self, mut m: &UnaryExprModel) {
        exprOptimizer.optimize(m.Expr.Model)
        if Ptr && m.Op.Kind == TokenKind.Star {
            match type m.Expr.Model {
            | &UnaryExprModel:
                let mut um = (&UnaryExprModel)(m.Expr.Model)
                if um.Op.Kind == TokenKind.Amper {
                    *self.model = um.Expr.Model
                }
            }
        }
    }

    fn structureLit(self, mut m: &StructLitExprModel) {
        for (_, mut arg) in m.Args {
            exprOptimizer.optimize(arg.Expr)
        }
    }

    fn allocStructure(self, mut m: &AllocStructLitExprModel) {
        self.structureLit(m.Lit)
    }

    fn casting(self, mut m: &CastingExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn args(self, mut &args: []ExprModel) {
        for (i, mut arg) in args {
            exprOptimizer.optimize(arg)
            args[i] = arg
        }
    }

    fn scope(self, mut &s: &Scope) {
        let mut scopt = scopeOptimizer.new(s)
        scopt.optimize()
    }

    fn funcCall(self, mut m: &FnCallExprModel) {
        exprOptimizer.optimize(m.Expr)
        self.args(m.Args)
        if m.Except != nil {
            self.scope(m.Except)
        }
    }

    fn slice(self, mut m: &SliceExprModel) {
        self.args(m.Elems)
    }

    fn array(self, mut m: &ArrayExprModel) {
        if len(m.Elems) == 2 && m.Elems[1] == nil {
            let mut elem = m.Elems[0]
            exprOptimizer.optimize(elem)
            m.Elems[0] = elem
        }
        self.args(m.Elems)
    }

    fn indexing(self, mut m: &IndexingExprModel) {
        exprOptimizer.optimize(m.Expr.Model)
        exprOptimizer.optimize(m.Index.Model)
        if !Access {
            ret
        }
        let array = m.Expr.Kind.Arr() != nil
        // Constants checked by semantic analysis for arrays, safe.
        if array && m.Index.IsConst() {
            let mut model: any = &UnsafeIndexingExprModel{Node: m}
            *self.model = unsafe { *(*ExprModel)(&model) }
            ret
        }
        match type m.Index.Model {
        | &Var:
            let i = (&Var)(m.Index.Model)
            if i.Mutable || i.IterRelation == nil {
                break
            }
            match type m.Expr.Model {
            | &Var:
                let r = (&Var)(m.Expr.Model)
                // Iterated variable is indexed variable?
                if i.IterRelation.Range == r {
                    let mut model: any = &UnsafeIndexingExprModel{Node: m}
                    *self.model = unsafe { *(*ExprModel)(&model) }
                }
            }
        }
    }

    fn anonFunc(self, mut m: &AnonFnExprModel) {
        self.scope(m.Func.Scope)
    }

    fn mapExpr(self, mut m: &MapExprModel) {
        for (_, mut pair) in m.Entries {
            exprOptimizer.optimize(pair.Key)
            exprOptimizer.optimize(pair.Val)
        }
    }

    fn slicing(self, mut m: &SlicingExprModel) {
        exprOptimizer.optimize(m.Expr)
        exprOptimizer.optimize(m.Left)
        if m.Right != nil {
            exprOptimizer.optimize(m.Right)
        }
    }

    fn traitSub(self, mut m: &TraitSubIdentExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn structureSub(self, mut m: &StructSubIdentExprModel) {
        exprOptimizer.optimize(m.Expr.Model)
    }

    fn commonSub(self, mut m: &CommonSubIdentExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn tuple(self, mut m: &TupleExprModel) {
        for (_, mut d) in m.Datas {
            exprOptimizer.optimize(d.Model)
        }
    }

    fn newCall(self, mut m: &BuiltinNewCallExprModel) {
        if m.Init != nil {
            exprOptimizer.optimize(m.Init)
        }
    }

    fn outCall(self, mut m: &BuiltinOutCallExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn outlnCall(self, mut m: &BuiltinOutlnCallExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn panicCall(self, mut m: &BuiltinPanicCallExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn assertCall(self, mut m: &BuiltinAssertCallExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn errorCall(self, mut m: &BuiltinErrorCallExprModel) {
        exprOptimizer.optimize(m.Err.Model)
    }

    fn makeCall(self, mut m: &BuiltinMakeCallExprModel) {
        if m.Len != nil {
            exprOptimizer.optimize(m.Len)
        }
        if m.Cap != nil {
            exprOptimizer.optimize(m.Cap)
        }
    }

    fn appendCall(self, mut m: &BuiltinAppendCallExprModel) {
        exprOptimizer.optimize(m.Dest)
        exprOptimizer.optimize(m.Elements)
    }

    fn lenCall(self, mut m: &BuiltinLenCallExprModel) {
        exprOptimizer.optimize(m.Expr.Model)
    }

    fn capCall(self, mut m: &BuiltinCapCallExprModel) {
        exprOptimizer.optimize(m.Expr.Model)
    }

    fn cloneCall(self, mut m: &BuiltinCloneCallExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn deleteCall(self, mut m: &BuiltinDeleteCallExprModel) {
        exprOptimizer.optimize(m.Dest.Model)
        if m.Key != nil {
            exprOptimizer.optimize(m.Key.Model)
        }
    }

    fn sizeof(self, mut m: &SizeofExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn alignof(self, mut m: &AlignofExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn integratedToStr(self, mut m: &IntegratedToStrExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn free(self, mut m: &FreeExprModel) {
        exprOptimizer.optimize(m.Expr)
    }

    fn backendEmit(self, mut m: &BackendEmitExprModel) {
        self.args(m.Exprs)
    }

    fn do(self) {
        match type *self.model {
        | &BinopExprModel:
            self.binary((&BinopExprModel)(*self.model))
        | &UnaryExprModel:
            self.unary((&UnaryExprModel)(*self.model))
        | &StructLitExprModel:
            self.structureLit((&StructLitExprModel)(*self.model))
        | &AllocStructLitExprModel:
            self.allocStructure((&AllocStructLitExprModel)(*self.model))
        | &CastingExprModel:
            self.casting((&CastingExprModel)(*self.model))
        | &FnCallExprModel:
            self.funcCall((&FnCallExprModel)(*self.model))
        | &SliceExprModel:
            self.slice((&SliceExprModel)(*self.model))
        | &ArrayExprModel:
            self.array((&ArrayExprModel)(*self.model))
        | &IndexingExprModel:
            self.indexing((&IndexingExprModel)(*self.model))
        | &AnonFnExprModel:
            self.anonFunc((&AnonFnExprModel)(*self.model))
        | &MapExprModel:
            self.mapExpr((&MapExprModel)(*self.model))
        | &SlicingExprModel:
            self.slicing((&SlicingExprModel)(*self.model))
        | &TraitSubIdentExprModel:
            self.traitSub((&TraitSubIdentExprModel)(*self.model))
        | &StructSubIdentExprModel:
            self.structureSub((&StructSubIdentExprModel)(*self.model))
        | &CommonSubIdentExprModel:
            self.commonSub((&CommonSubIdentExprModel)(*self.model))
        | &TupleExprModel:
            self.tuple((&TupleExprModel)(*self.model))
        | &BuiltinOutCallExprModel:
            self.outCall((&BuiltinOutCallExprModel)(*self.model))
        | &BuiltinOutlnCallExprModel:
            self.outlnCall((&BuiltinOutlnCallExprModel)(*self.model))
        | &BuiltinNewCallExprModel:
            self.newCall((&BuiltinNewCallExprModel)(*self.model))
        | &BuiltinPanicCallExprModel:
            self.panicCall((&BuiltinPanicCallExprModel)(*self.model))
        | &BuiltinAssertCallExprModel:
            self.assertCall((&BuiltinAssertCallExprModel)(*self.model))
        | &BuiltinErrorCallExprModel:
            self.errorCall((&BuiltinErrorCallExprModel)(*self.model))
        | &BuiltinMakeCallExprModel:
            self.makeCall((&BuiltinMakeCallExprModel)(*self.model))
        | &BuiltinAppendCallExprModel:
            self.appendCall((&BuiltinAppendCallExprModel)(*self.model))
        | &BuiltinLenCallExprModel:
            self.lenCall((&BuiltinLenCallExprModel)(*self.model))
        | &BuiltinCapCallExprModel:
            self.capCall((&BuiltinCapCallExprModel)(*self.model))
        | &BuiltinCloneCallExprModel:
            self.cloneCall((&BuiltinCloneCallExprModel)(*self.model))
        | &BuiltinDeleteCallExprModel:
            self.deleteCall((&BuiltinDeleteCallExprModel)(*self.model))
        | &SizeofExprModel:
            self.sizeof((&SizeofExprModel)(*self.model))
        | &AlignofExprModel:
            self.alignof((&AlignofExprModel)(*self.model))
        | &IntegratedToStrExprModel:
            self.integratedToStr((&IntegratedToStrExprModel)(*self.model))
        | &FreeExprModel:
            self.free((&FreeExprModel)(*self.model))
        | &BackendEmitExprModel:
            self.backendEmit((&BackendEmitExprModel)(*self.model))
        }
    }
}

// Checks for bit-shifting optimizations.
// Reports true if conditions are:
//   - l is integer
//   - r is integer
//   - r is constant
//   - r > 0 && r%2 == 0
//   - log2(r) returns integer without fraction
//
// As a result: returns whether bit-shifting is possible and what nth power of 2^r.
fn checkForBitShiftOpt(&l: &OperandExprModel, &r: &OperandExprModel): (ok: bool, x: u64) {
    if !types::IsInt(l.Kind.Str()) || !types::IsInt(r.Kind.Str()) {
        ret false, 0
    }
    match type r.Model {
    | &Const:
        break
    |:
        ret false, 0
    }
    x = (&Const)(r.Model).AsU64()
    if x == 0 || x%2 != 0 {
        ret false, 0
    }
    let j = math::Log2(f64(x))
    let z = u64(j)
    if f64(z) != j {
        ret false, 0
    }
    ret true, z
}